From ab68b8d16e77e73104f9a8a2230cfc34396d7da0 Mon Sep 17 00:00:00 2001
From: Score_Under <seejay.11@gmail.com>
Date: Sun, 18 Aug 2019 22:40:15 +0100
Subject: [PATCH 1/3] docs: Compatibility with new Python and Perl versions

---
 docs/mksite.pl                        | 20 +++++++++----------
 docs/zzipdoc/commentmarkup.py         |  2 +-
 docs/zzipdoc/dbk2htm.py               |  6 +++---
 docs/zzipdoc/docbookdocument.py       | 27 +++++++++++++-------------
 docs/zzipdoc/functionheader.py        |  2 +-
 docs/zzipdoc/functionlisthtmlpage.py  |  9 +++++----
 docs/zzipdoc/functionlistreference.py |  7 ++++---
 docs/zzipdoc/functionprototype.py     |  2 +-
 docs/zzipdoc/htm2dbk.py               | 10 +++++-----
 docs/zzipdoc/htmldocument.py          | 25 ++++++++++++------------
 docs/zzipdoc/match.py                 | 28 ++++++++-------------------
 docs/zzipdoc/options.py               | 12 ++----------
 docs/zzipdoc/textfile.py              |  3 ---
 docs/zzipdoc/textfileheader.py        |  5 +++--
 14 files changed, 70 insertions(+), 88 deletions(-)

diff --git a/docs/mksite.pl b/docs/mksite.pl
index a463b3a..a8ab53f 100644
--- a/docs/mksite.pl
+++ b/docs/mksite.pl
@@ -340,7 +340,7 @@ sub mksite_magic_option
 push @MK_TAGS, "s|<!--[$AX]*[?]-->||g;";
 push @MK_TAGS, "s|<!--\\\$[$AX]*[?]:-->||g;";
 push @MK_TAGS, "s|<!--\\\$[$AX]*:[?=]-->||g;";
-push @MK_TAGS, "s|(<[^<>]*)\\\${[$AX]*:[?=]([^<{}>]*)}([^<>]*>)|\$1\$2\$3|g;";
+push @MK_TAGS, "s|(<[^<>]*)\\\$\\{[$AX]*:[?=]([^<{}>]*)}([^<>]*>)|\$1\$2\$3|g;";
 
 my $TRIMM=" -e 's:^ *::' -e 's: *\$::'";  # trimm away leading/trailing spaces
 sub trimm
@@ -544,17 +544,17 @@ sub info2vars_sed      # generate <!--$vars--> substition sed addon script
     if ($attribvars ne "no") {
 	for (@_INP) {  my $H = "[^<>]*";
     if    (/^=....=formatter /) { next; }
-    elsif (/^<$Q='text'>$V9/){push @OUT,"\$Z='$2';s|<$V1\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='Text'>$V9/){push @OUT,"\$Z='$2';s|<$V1\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='name'>$V9/){push @OUT,"\$Z='$2';s|<$V1\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='Name'>$V9/){push @OUT,"\$Z='$2';s|<$V1\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='text'>$V8/){push @OUT,"\$Z='$2';s|<$V1\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='Text'>$V8/){push @OUT,"\$Z='$2';s|<$V1\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='name'>$V8/){push @OUT,"\$Z='$2';s|<$V1\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
-    elsif (/^<$Q='Name'>$V8/){push @OUT,"\$Z='$2';s|<$V1\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"} 
+    elsif (/^<$Q='text'>$V9/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='Text'>$V9/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='name'>$V9/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='Name'>$V9/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='text'>$V8/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='Text'>$V8/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[=]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='name'>$V8/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
+    elsif (/^<$Q='Name'>$V8/){push @OUT,"\$Z='$2';s|<$V1\\{$1:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
 	}
         for (split / /, $o{variables}) {
-	    {push @OUT,"\$Z='$o{$_}';s|<$V1\{$_:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"} 
+	    {push @OUT,"\$Z='$o{$_}';s|<$V1\\{$_:[?]$V2}$V3>|<\$1$SS\$Z\$3>|;"}
 	}
     }
     # if value="2004" then generated sed might be "\\12004" which is bad
diff --git a/docs/zzipdoc/commentmarkup.py b/docs/zzipdoc/commentmarkup.py
index 232f758..02a235e 100644
--- a/docs/zzipdoc/commentmarkup.py
+++ b/docs/zzipdoc/commentmarkup.py
@@ -1,4 +1,4 @@
-from match import Match
+from .match import Match
 
 def markup_link_syntax(text):
     """ markup the link-syntax ` => somewhere ` in the text block """
diff --git a/docs/zzipdoc/dbk2htm.py b/docs/zzipdoc/dbk2htm.py
index f8593e6..9296ab8 100644
--- a/docs/zzipdoc/dbk2htm.py
+++ b/docs/zzipdoc/dbk2htm.py
@@ -1,4 +1,4 @@
-from match import Match
+from .match import Match
 import string
 
 class dbk2htm_conversion:
@@ -8,8 +8,8 @@ class dbk2htm_conversion:
     def __init__(self):
         pass
     def section2html(self, text):
-        for str in self.mapping:
-            text = string.replace(text, str, self.mapping[str])
+        for find, replace in self.mapping.items():
+            text = text.replace(find, replace)
         return text
     def paramdef2html(self, text):
         s = Match()
diff --git a/docs/zzipdoc/docbookdocument.py b/docs/zzipdoc/docbookdocument.py
index 072dc16..8656a69 100644
--- a/docs/zzipdoc/docbookdocument.py
+++ b/docs/zzipdoc/docbookdocument.py
@@ -1,6 +1,7 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
-from match import Match
+from __future__ import print_function
+from .match import Match
 
 class DocbookDocument:
     """ binds some xml content page with additional markup - in this
@@ -30,7 +31,7 @@ def _xml_doctype(self, rootnode):
     def _xml_text(self, xml):
         """ accepts adapter objects with .xml_text() """
         try:   return xml.xml_text()
-        except Exception as e: print "DocbookDocument/text", e; pass
+        except Exception as e: print("DocbookDocument/text", e); pass
         return str(xml)
     def _fetch_rootnode(self, text):
         fetch = Match(r"^[^<>]*<(\w+)\b")
@@ -47,7 +48,7 @@ def _filename(self, filename):
         return filename
     def save(self, filename = None):
         filename = self._filename(filename)
-        print "writing '"+filename+"'"
+        print("writing '"+filename+"'")
         if len(self.text) > 1:
             self.save_all(filename)
         else:
@@ -58,12 +59,12 @@ def save_text(self, filename, text):
             xml_text = self._xml_text(text)
             rootnode = self._fetch_rootnode(xml_text)
             doctype = self._xml_doctype(rootnode)
-            print >>fd, doctype
-            print >>fd, xml_text
+            print(doctype, file=fd)
+            print(xml_text, file=fd)
             fd.close()
             return True
         except IOError as e:
-            print "could not open '"+filename+"'file", e
+            print("could not open '"+filename+"'file", e)
             return False
     def save_all(self, filename):
         assert len(self.text) > 1
@@ -76,20 +77,20 @@ def save_all(self, filename):
             else:
                 rootnode = self.rootnode
             doctype = self._xml_doctype(rootnode)
-            print >>fd, doctype
+            print(doctype, file=fd)
             title = self.get_title()
             if title and self.rootnode in self.has_title_child:
-                print >>fd, "<"+self.rootnode+'><title>'+title+'</title>'
+                print("<"+self.rootnode+'><title>'+title+'</title>', file=fd)
             elif title:
-                print >>fd, "<"+self.rootnode+' id="'+title+'">'
+                print("<"+self.rootnode+' id="'+title+'">', file=fd)
             else:
-                print >>fd, "<"+self.rootnode+'>'
+                print("<"+self.rootnode+'>', file=fd)
             for text in self.text:
                 text = self._xml_text(text)
-                print >>fd, text
-            print >>fd, "</"+self.rootnode+">"
+                print(text, file=fd)
+            print("</"+self.rootnode+">", file=fd)
             fd.close()
             return True
         except IOError as e:
-            print "could not open '"+filename+"'file", e
+            print("could not open '"+filename+"' file", e)
             return False
diff --git a/docs/zzipdoc/functionheader.py b/docs/zzipdoc/functionheader.py
index 81bb385..cc4235f 100644
--- a/docs/zzipdoc/functionheader.py
+++ b/docs/zzipdoc/functionheader.py
@@ -1,4 +1,4 @@
-from match import Match
+from .match import Match
 
 class FunctionHeader:
     """ parsing the comment block that is usually presented before
diff --git a/docs/zzipdoc/functionlisthtmlpage.py b/docs/zzipdoc/functionlisthtmlpage.py
index efbde94..7f8d2e0 100644
--- a/docs/zzipdoc/functionlisthtmlpage.py
+++ b/docs/zzipdoc/functionlisthtmlpage.py
@@ -1,5 +1,6 @@
-from options import *
-from match import Match
+from __future__ import print_function
+from .options import *
+from .match import Match
 
 class FunctionListHtmlPage:
     """ The main part here is to create a TOC (table of contents) at the
@@ -35,7 +36,7 @@ def add(self, entry):
         head_text = entry.head_xml_text()
         body_text = entry.body_xml_text(name)
         if not head_text:
-            print "no head_text for", name
+            print("no head_text for", name)
             return
         try:
             prespec = entry.head_get_prespec()
@@ -102,7 +103,7 @@ def resolve_links(self, text):
         text &= (Match("(?s)<link>(\w+)</link>")
                  >> (lambda x: self.resolve_internal(x.group(1))))
         if len(self.not_found_in_anchors):
-            print "not found in anchors: ", self.not_found_in_anchors
+            print("not found in anchors:", self.not_found_in_anchors)
         return (text & Match("(?s)<link>([^<>]*)</link>")
                 >> "<code>\\1</code>")
     def resolve_external(self, func, sect):
diff --git a/docs/zzipdoc/functionlistreference.py b/docs/zzipdoc/functionlistreference.py
index c38ff0a..afbf1cf 100644
--- a/docs/zzipdoc/functionlistreference.py
+++ b/docs/zzipdoc/functionlistreference.py
@@ -1,7 +1,8 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
-from match import Match
-from htm2dbk import *
+from __future__ import print_function
+from .match import Match
+from .htm2dbk import *
 
 class FunctionListReference:
     """ Creating a docbook-style <reference> list of <refentry> parts
@@ -19,7 +20,7 @@ def add(self, entry):
         description = entry.body_xml_text(name)
         funcsynopsis = entry.head_xml_text()
         if not funcsynopsis:
-            print "no funcsynopsis for", name
+            print("no funcsynopsis for", name)
             return
         if self.entry is None:
             self.entry = FunctionListRefEntry(entry, self.o)
diff --git a/docs/zzipdoc/functionprototype.py b/docs/zzipdoc/functionprototype.py
index fda85bb..b7f03cf 100644
--- a/docs/zzipdoc/functionprototype.py
+++ b/docs/zzipdoc/functionprototype.py
@@ -1,4 +1,4 @@
-from match import Match
+from .match import Match
 
 class FunctionPrototype:
     """ takes a single function prototype line (cut from some source file)
diff --git a/docs/zzipdoc/htm2dbk.py b/docs/zzipdoc/htm2dbk.py
index 98b4f67..1b8749e 100644
--- a/docs/zzipdoc/htm2dbk.py
+++ b/docs/zzipdoc/htm2dbk.py
@@ -6,12 +6,12 @@
 want is the docbook-to-pdf converter and similar technology being
 present in the world of docbook-to-anything converters. """
 
+from __future__ import absolute_import, print_function
+
 from datetime import date
-import match
+from .match import Match as m
 import sys
 
-m = match.Match
-
 class htm2dbk_conversion_base:
     regexlist = [
         m()("</[hH]2>(.*)", "m") >> "</title>\n<subtitle>\\1</subtitle>",
@@ -147,7 +147,7 @@ def htm2dbk_files(args):
             doc.add(f.read())
             f.close()
         except IOError as e:
-            print >> sys.stderr, "can not open "+filename
+            print("can not open", filename, file=sys.stderr)
     return doc.value()
 
 def html2docbook(text):
@@ -155,4 +155,4 @@ def html2docbook(text):
     return htm2dbk_conversion().convert2(text)
 
 if __name__ == "__main__":
-    print htm2dbk_files(sys.argv[1:])
+    print(htm2dbk_files(sys.argv[1:]))
diff --git a/docs/zzipdoc/htmldocument.py b/docs/zzipdoc/htmldocument.py
index 7a58eca..aefb2e9 100644
--- a/docs/zzipdoc/htmldocument.py
+++ b/docs/zzipdoc/htmldocument.py
@@ -1,6 +1,7 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
-from match import Match
+from __future__ import print_function
+from .match import Match
 
 class HtmlDocument:
     """ binds some html content page with additional markup - in this
@@ -40,20 +41,20 @@ def _html_style(self, style):
         """ accepts adapter objects with .html_style() and .xml_style() """
         ee = None
         try:   return style.html_style()
-        except Exception as e: ee = e; pass
+        except Exception as e: ee = e
         try:   return style.xml_style()
-        except Exception as e: print "HtmlDocument/style", ee, e; pass
+        except Exception as e: print("HtmlDocument/style", ee, e)
         try:   return str(style)
-        except Exception as e: print "HtmlDocument/style", e; return ""
+        except Exception as e: print("HtmlDocument/style", e); return ""
     def _html_text(self, html):
         """ accepts adapter objects with .html_text() and .xml_text() """
         ee = None
         try:   return html.html_text()
-        except Exception as e: ee = e; pass
+        except Exception as e: ee = e
         try:   return html.xml_text()
-        except Exception as e: print "HtmlDocument/text", ee, e; pass
+        except Exception as e: print("HtmlDocument/text", ee, e)
         try:   return str(html)
-        except Exception as e: print "HtmlDocument/text", e; return "&nbsp;"
+        except Exception as e: print("HtmlDocument/text", e); return "&nbsp;"
     def navigation(self):
         if self.navi:
             return self.navi
@@ -103,15 +104,15 @@ def _filename(self, filename):
         return filename
     def save(self, filename = None):
         filename = self._filename(filename)
-        print "writing '"+filename+"'"
+        print("writing '"+filename+"'")
         try:
             fd = open(filename, "w")
-            print >>fd, self.html_header()
+            print(self.html_header(), file=fd)
             for text in self.text:
-                print >>fd, self._html_text(text)
-            print >>fd, self.html_footer()
+                print(self._html_text(text), file=fd)
+            print(self.html_footer(), file=fd)
             fd.close()
             return True
         except IOError as e:
-            print "could not open '"+filename+"'file", e
+            print("could not open '"+filename+"'file", e)
             return False
diff --git a/docs/zzipdoc/match.py b/docs/zzipdoc/match.py
index a089ec3..5d81609 100644
--- a/docs/zzipdoc/match.py
+++ b/docs/zzipdoc/match.py
@@ -7,7 +7,7 @@
 
 # ---------------------------------------------------------- Regex Match()
 # beware, stupid python interprets backslashes in replace-parts only partially!
-class MatchReplace:
+class MatchReplace(object):
     """ A MatchReplace is a mix of a Python Pattern and a Replace-Template """
     def __init__(self, matching, template, count = 0, flags = None):
         """ setup a substition from regex 'matching' into 'template',
@@ -18,8 +18,10 @@ def __init__(self, matching, template, count = 0, flags = None):
         MatchReplace.__call__(self, matching, template, count, flags)
     def __call__(self, matching, template = None, count = 0, flags = None):
         """ other than __init__ the template may be left off to be unchanged"""
-        if isinstance(count, basestring): # count/flags swapped over?
-            flags = count; count = 0
+        if not isinstance(count, int):
+            raise Exception("Shouldn't have count as non int")
+        #if isinstance(count, basestring): # count/flags swapped over?
+        #    flags = count; count = 0
         if isinstance(matching, Match):
             self.matching = matching
         else:
@@ -48,7 +50,7 @@ def __rshift__(self, count):
     def __rlshift__(self, count):
         self.count = count ; return self
 
-class Match(str):
+class Match(object):
     """ A Match is actually a mix of a Python Pattern and MatchObject """
     def __init__(self, pattern = None, flags = None):
         """ flags is a string: 'i' for case-insensitive etc.; it is just
@@ -57,7 +59,6 @@ def __init__(self, pattern = None, flags = None):
     def __call__(self, pattern, flags = None):
         assert isinstance(pattern, str) or pattern is None
         assert isinstance(flags, str) or flags is None
-        str.__init__(self, pattern)
         self.replaced = 0 # set by subn() inside MatchReplace
         self.found = None # set by search() to a MatchObject
         self.pattern = pattern
@@ -81,23 +82,10 @@ def __rlshift__(self, template):
         return MatchReplace(self, template)
     def __getitem__(self, index):
         return self.group(index)
+    def __str__(self):
+        return self.pattern
     def group(self, index):
         assert self.found is not None
         return self.found.group(index)
     def finditer(self, string):
         return self.regex.finditer(string)
-
-if __name__ == "__main__":
-    # matching:
-    if "foo" & Match("oo"):
-        print "oo"
-    x = Match()
-    if "foo" & x("(o+)"):
-        print x[1]
-    # replacing:
-    y = "fooboo" & Match("oo") >> "ee"
-    print y
-    r = Match("oo") >> "ee"
-    print "fooboo" & r
-    s = MatchReplace("oo", "ee")
-    print "fooboo" & s
diff --git a/docs/zzipdoc/options.py b/docs/zzipdoc/options.py
index c6758d5..230df40 100644
--- a/docs/zzipdoc/options.py
+++ b/docs/zzipdoc/options.py
@@ -3,14 +3,13 @@
 # @creator (C) 2003 Guido U. Draheim
 # @license http://creativecommons.org/licenses/by-nc-sa/2.0/de/
 
-from match import Match
+from .match import Match
 
 # use as o.optionname to check for commandline options.
 class Options:
     var = {}
     def __getattr__(self, name):
-        if not self.var.has_key(name): return None
-        return self.var[name]
+        return self.var.get(name)
     def __setattr__(self, name, value):
         self.var[name] = value
     def scan(self, optionstring): # option-name or None
@@ -22,10 +21,3 @@ def scan(self, optionstring): # option-name or None
         if optionstring & x(r"^--?(\w+)$"):
             self.var[x[1]] = "*"; return x[1]
         return None
-#end Options
-
-if False:
-    o = Options()
-    o.help = """
-    scans for options
-    """
diff --git a/docs/zzipdoc/textfile.py b/docs/zzipdoc/textfile.py
index 1c8b935..51728af 100644
--- a/docs/zzipdoc/textfile.py
+++ b/docs/zzipdoc/textfile.py
@@ -1,4 +1,3 @@
-
 def _src_to_xml(text):
     return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt")
 
@@ -45,5 +44,3 @@ def _line(self, text, offset):
             if x == "\n":
                 line += 1
         return line
-            
-
diff --git a/docs/zzipdoc/textfileheader.py b/docs/zzipdoc/textfileheader.py
index ceaa28e..099b618 100644
--- a/docs/zzipdoc/textfileheader.py
+++ b/docs/zzipdoc/textfileheader.py
@@ -1,4 +1,5 @@
-from match import Match
+from __future__ import print_function
+from .match import Match
 
 class TextFileHeader:
     """ scan for a comment block at the source file start and fill the
@@ -17,7 +18,7 @@ def parse(self, textfile = None):
         x = Match()
         text = self.textfile.get_src_text()
         if not text:
-            print "nonexistent file:", self.textfile.get_filename()
+            print("nonexistent file:", self.textfile.get_filename())
             return False
         if text & x(r"(?s)[/][*]+(\s(?:.(?!\*\/))*.)\*\/"
                     r"(?:\s*\#(?:define|ifdef|endif)[ ]*\S*[ ]*\S*)*"

From 26ef9dfbcf20df7ea0b0b8044856187fe8fc7a4d Mon Sep 17 00:00:00 2001
From: Score_Under <seejay.11@gmail.com>
Date: Sun, 18 Aug 2019 23:24:41 +0100
Subject: [PATCH 2/3] Remove some unused doc scripts; tidy zzipdoc

Still more a vehicle for regexes than a python script, but a little
easier to read now.
---
 docs/Makefile.am                      |    2 +-
 docs/Makefile.in                      |    2 +-
 docs/cpp2markdown-1.py                |  249 ------
 docs/cpp2markdown.py                  |  195 -----
 docs/dbk2man.py                       |  295 ++++---
 docs/dir2index.py                     |   47 +-
 docs/make-doc.py                      | 1028 -------------------------
 docs/makedocs.py                      |  545 +++++++------
 docs/zzipdoc/commentmarkup.py         |  143 ++--
 docs/zzipdoc/dbk2htm.py               |   43 +-
 docs/zzipdoc/docbookdocument.py       |  133 ++--
 docs/zzipdoc/document.py              |   12 +
 docs/zzipdoc/functionheader.py        |  102 +--
 docs/zzipdoc/functionlisthtmlpage.py  |  192 +++--
 docs/zzipdoc/functionlistreference.py |  314 ++++----
 docs/zzipdoc/functionprototype.py     |   70 +-
 docs/zzipdoc/htm2dbk.py               |  232 +++---
 docs/zzipdoc/htmldocument.py          |  133 +---
 docs/zzipdoc/match.py                 |   91 ---
 docs/zzipdoc/options.py               |   23 -
 docs/zzipdoc/textfile.py              |   52 +-
 docs/zzipdoc/textfileheader.py        |   73 +-
 22 files changed, 1072 insertions(+), 2904 deletions(-)
 delete mode 100755 docs/cpp2markdown-1.py
 delete mode 100644 docs/cpp2markdown.py
 delete mode 100644 docs/make-doc.py
 create mode 100644 docs/zzipdoc/document.py
 delete mode 100644 docs/zzipdoc/match.py
 delete mode 100644 docs/zzipdoc/options.py

diff --git a/docs/Makefile.am b/docs/Makefile.am
index d0f9eb3..6f40bb2 100644
--- a/docs/Makefile.am
+++ b/docs/Makefile.am
@@ -20,7 +20,7 @@ SDL_RWOPS = $(SDL)/SDL_rwops_zzcat.c \
             $(SDL)/SDL_rwops_zzip.c $(SDL)/SDL_rwops_zzip.h
 changelog = @top_srcdir@/ChangeLog
 
-EXTRA_DIST = make-doc.py $(doc_FILES) $(htm_FILES) $(SDL_RWOPS) \
+EXTRA_DIST = $(doc_FILES) $(htm_FILES) $(SDL_RWOPS) \
              make-doc.pl make-dbk.pl   mksite.sh mksite.pl body.htm \
              dbk2man.py dir2index.py \
              $(zzipdoc_FILES) sdocbook.css \
diff --git a/docs/Makefile.in b/docs/Makefile.in
index c4fbd88..acbfefe 100644
--- a/docs/Makefile.in
+++ b/docs/Makefile.in
@@ -323,7 +323,7 @@ SDL_RWOPS = $(SDL)/SDL_rwops_zzcat.c \
             $(SDL)/SDL_rwops_zzip.c $(SDL)/SDL_rwops_zzip.h
 
 changelog = @top_srcdir@/ChangeLog
-EXTRA_DIST = make-doc.py $(doc_FILES) $(htm_FILES) $(SDL_RWOPS) \
+EXTRA_DIST = $(doc_FILES) $(htm_FILES) $(SDL_RWOPS) \
              make-doc.pl make-dbk.pl   mksite.sh mksite.pl body.htm \
              dbk2man.py dir2index.py \
              $(zzipdoc_FILES) sdocbook.css \
diff --git a/docs/cpp2markdown-1.py b/docs/cpp2markdown-1.py
deleted file mode 100755
index 60d28c4..0000000
--- a/docs/cpp2markdown-1.py
+++ /dev/null
@@ -1,249 +0,0 @@
-#! /usr/bin/env python
-import pygments.lexers.compiled as lexer
-import optparse
-import re
-from pygments.token import Token
-import logging
-
-logg = logging.getLogger(__name__)
-
-FileComment = "FileComment"
-FileInclude = "FileInclude"
-FunctionComment = "FunctionComment"
-FunctionPrototype = "FunctionPrototype"
-
-# use the markdown lexer to identify elements
-# then filter only those we want. The returned
-# token list is more global flagging the role
-# of each token for the manual generation.
-class CppToMarkdown:
-    def __init__(self):
-        self.alldefinitions = 0
-        self.internaldefs = ["static"]
-        self.filecomment_done = ""
-        self.fileinclude_done = ""
-        self.filecomment_text = ""
-        self.fileinclude_text = ""
-        self.comment_text = ""
-        self.function_text = ""
-        self.nesting = 0
-    def split_copyright(self, text):
-        # there are two modes - the copyright starts in the first line
-        # and the source description follows or the other way round.
-        lines = text.split("\n")
-        if len(lines) <= 2:
-            return "", text
-        introtext = [lines[0]]
-        copyright = [lines[0]]
-        check1 = re.compile(r"^\s[*]\s+[(][c][C][)]")
-        check2 = re.compile(r"^\s[*]\s+\b[Cc]opyright\b")
-        empty1 = re.compile(r"^\s[*]\s*$")
-        state = "intro"
-        for i in xrange(1,len(lines)-1):
-            line = lines[i]
-            if state == "intro":
-                if empty1.match(line):
-                    introtext += [ line ]
-                    continue
-                if check1.match(line) or check2.match(line):
-                    state = "copyrightfirst"
-                    copyright += [ line ]
-                else:
-                    state = "introtextfirst"
-                    introtext += [ line ]
-            elif state == "copyrightfirst":
-                if empty1.match(line):
-                    state = "introtextlast"
-                    introtext += [ line ]
-                else:
-                    copyright += [ line ]
-            elif state == "introtextfirst":
-                if check1.match(line) or check2.match(line):
-                    state = "copyrightlast"
-                    copyright += [ line ]
-                else:
-                    introtext += [ line ]
-            elif state == "copyrightlast":
-                copyright += [ line ]
-            elif state == "introtextlast":
-                introtext += [ line ]
-            else:
-                logg.fatal("UNKNOWN STATE %s", state)
-        introtext += [lines[-1]]
-        copyright += [lines[-1]]
-        logg.debug("@ COPYRIGHT\n %s", copyright)
-        logg.debug("@ INTROTEXT\n %s", introtext)
-        return "\n".join(copyright), "\n".join(introtext)
-    def commentblock(self, text):
-        prefix = re.compile(r"(?s)^\s*[/][*]+([^\n]*)(?=\n)")
-        suffix = re.compile(r"(?s)\n [*][/]\s*")
-        empty = re.compile(r"(?s)\n [*][ \t]*(?=\n)")
-        lines1 = re.compile(r"(?s)\n [*][ ][\t]")
-        lines2 = re.compile(r"(?s)\n [*][ ]")
-        lines3 = re.compile(r"(?s)\n [*][\t][\t]")
-        lines4 = re.compile(r"(?s)\n [*][\t]")
-        text = suffix.sub("\n", text)
-        text = prefix.sub("> \\1\n", text)
-        text = empty.sub("\n", text)
-        text = lines1.sub("\n     ", text)
-        text = lines2.sub("\n", text)
-        text = lines3.sub("\n         ", text)
-        text = lines4.sub("\n     ", text)
-        return text
-    def functionblock(self, text):
-        empty = re.compile(r"(?s)\n[ \t]*(?=\n)")
-        text = "    " + text.replace("\n", "\n    ")
-        text = empty.sub("", text) 
-        return text
-    def functionname(self, text):
-        check1 = re.compile(r"^[^()=]*(\b\w+)\s*[(=]")
-        found = check1.match(text)
-        if found:
-            return found.group(1)
-        check2 = re.compile(r"^[^()=]*(\b\w+)\s*$")
-        found = check2.match(text)
-        if found:
-            return found.group(1)
-        return ""
-    def run(self, filename):
-        filetext = open(filename).read()
-        for line in self.process(filetext, filename):
-            print line
-    def process(self, filetext, filename=""):
-        section_ruler = "-----------------------------------------"
-        copyright = ""
-        for token, text in self.parse(filetext):
-            if token == FileInclude:
-                yield "## SOURCE " + filename.replace("../", "")
-                yield "    #" + text.replace("\n", "\n    ")
-            elif token == FileComment:
-                yield "### INTRODUCTION"
-                copyright, introduction = self.split_copyright(text)
-                yield self.commentblock(introduction)
-            elif token == FunctionPrototype:
-                name = self.functionname(text)
-                yield section_ruler
-                yield "### " + name
-                # yield '<a id="%s"></a>' % name
-                yield "#### NAME"
-                yield "    " + name
-                yield "#### SYNOPSIS"
-                yield self.functionblock(text)
-            elif token == FunctionComment:
-                if text:
-                    yield "#### DESCRIPTION"
-                    yield self.commentblock(text)
-            else:
-                if text:
-                    yield "#### NOTES"
-                    print token, text.replace("\n", "\n  ")
-        if copyright:
-            yield section_ruler
-            yield "### COPYRIGHT"
-            yield self.commentblock(copyright)            
-    def isexported_function(self):
-        function = self.function_text.strip().replace("\n"," ")
-        logg.debug("@ --------------------------------------") 
-        logg.debug("@ ALLDEFINITIONS %s", self.alldefinitions)
-        if function.startswith("static ") and self.alldefinitions < 3:
-            logg.debug("@ ONLY INTERNAL %s", function)
-            return False
-        if not self.comment_text:
-            if not self.alldefinitions:
-                logg.info("@ NO COMMENT ON %s", function)
-                return False
-            else:
-                logg.warn("@ NO COMMENT ON %s", function)
-        text = self.comment_text
-        if text.startswith("/**"): return True
-        if text.startswith("/*!"): return True
-        if text.startswith("///"): return True
-        if text.startswith("//!"): return True
-        if self.alldefinitions >= 1:
-            if text.startswith("/*"): return True
-            if text.startswith("//"): return True
-        if self.alldefinitions >= 2:
-            return True
-        logg.debug("@ NO ** COMMENT %s", self.function_text.strip())
-        defs = self.function_text
-        return False
-    def parse(self, filetext):
-        c = lexer.CLexer()
-        for token, text in c.get_tokens(filetext):
-            logg.debug("|| %s %s", token, text.replace("\n", "\n |"))
-            # completion
-            if token != Token.Comment.Preproc and self.fileinclude_done == "no":
-                    yield FileInclude, self.fileinclude_text
-                    if self.filecomment_text:
-                        yield FileComment, self.filecomment_text
-                    self.fileinclude_done = "done"
-            # parsing
-            if token == Token.Comment.Multiline:
-                if not self.filecomment_done:
-                    self.filecomment_done = "done"
-                    self.filecomment_text = text
-                    # wait until we know it is not a function documentation
-                    self.comment_text = text
-                else:
-                    self.comment_text = text
-            elif token == Token.Comment.Preproc and "include" in text:
-                if not self.fileinclude_done:
-                    self.fileinclude_done = "no"
-                    self.fileinclude_text += text
-                    self.comment_text = ""
-            elif token == Token.Comment.Preproc and self.fileinclude_done == "no":
-                if not "\n" in self.fileinclude_text:
-                    self.fileinclude_text += text
-                self.comment_text = ""
-            elif token == Token.Comment.Preproc:
-                    self.comment_text = ""
-                    self.function_text = ""
-            elif token == Token.Operator and text == "=":
-                if not self.nesting and self.function_text.strip():
-                    if self.isexported_function():
-                        yield FunctionPrototype, self.function_text
-                        yield FunctionComment, self.comment_text
-                self.comment_text = ""
-                self.function_text = ""
-            elif token == Token.Punctuation and text == ";":
-                self.comment_text = ""
-                self.function_text = ""
-            elif token == Token.Punctuation and text == "{":
-                if not self.nesting and self.function_text.strip():
-                    if self.isexported_function():
-                        yield FunctionPrototype, self.function_text
-                        yield FunctionComment, self.comment_text
-                self.comment_text = ""
-                self.function_text = ""
-                self.nesting += 1
-            elif token == Token.Punctuation and text == "}":
-                self.nesting -= 1
-                self.comment_text = ""
-                self.function_text = ""
-            else:
-                if not self.nesting:
-                    self.function_text += text
-                else:
-                    pass # yield "|",text
-                
-
-if __name__ == "__main__":
-    _o = optparse.OptionParser()
-    _o.add_option("-v", "--verbose", action="count", default=0)
-    _o.add_option("-a", "--all", action="count", default=0,
-                  help="include all definitions in the output (not only /**)")
-    opt, args = _o.parse_args()
-
-    logg.addHandler(logging.StreamHandler())
-    if opt.verbose:
-        logg.setLevel(logging.WARN - 10 * opt.verbose)
-    
-    c = CppToMarkdown()
-    if opt.all:
-        c.alldefinitions = opt.all
-    for arg in args:
-        c.run(arg)
-    
-    
-
-
diff --git a/docs/cpp2markdown.py b/docs/cpp2markdown.py
deleted file mode 100644
index 710bbdc..0000000
--- a/docs/cpp2markdown.py
+++ /dev/null
@@ -1,195 +0,0 @@
-import pygments.lexers.compiled as lexer
-import optparse
-import re
-from pygments.token import Token
-import logging
-
-logg = logging.getLogger(__name__)
-
-FileComment = "FileComment"
-FileInclude = "FileInclude"
-FunctionComment = "FunctionComment"
-FunctionPrototype = "FunctionPrototype"
-
-# use the markdown lexer to identify elements
-# then filter only those we want. The returned
-# token list is more global flagging the role
-# of each token for the manual generation.
-class CppToMarkdown:
-    def __init__(self):
-        self.alldefinitions = 0
-        self.internaldefs = ["static"]
-        self.filecomment_done = ""
-        self.fileinclude_done = ""
-        self.filecomment_text = ""
-        self.fileinclude_text = ""
-        self.comment_text = ""
-        self.function_text = ""
-        self.nesting = 0
-    def commentblock(self, text):
-        emptyprefix = re.compile(r"(?s)^\s*[/][*]+[ \t]*(?=\n)")
-        prefix = re.compile(r"(?s)^\s*[/][*]+([^\n]*)(?=\n)")
-        suffix = re.compile(r"(?s)\n [*][/]\s*")
-        empty = re.compile(r"(?s)\n [*][ \t]*(?=\n)")
-        lines1 = re.compile(r"(?s)\n [*][ ][\t]")
-        lines2 = re.compile(r"(?s)\n [*][ ]")
-        lines3 = re.compile(r"(?s)\n [*][\t][\t]")
-        lines4 = re.compile(r"(?s)\n [*][\t]")
-        text = suffix.sub("\n", text)
-        text = emptyprefix.sub("", text)
-        text = prefix.sub("> \\1\n", text)
-        text = empty.sub("\n", text)
-        text = lines1.sub("\n     ", text)
-        text = lines2.sub("\n", text)
-        text = lines3.sub("\n         ", text)
-        text = lines4.sub("\n     ", text)
-        return text
-    def functionblock(self, text):
-        empty = re.compile(r"(?s)\n[ \t]*(?=\n)")
-        text = "    " + text.replace("\n", "\n    ")
-        text = empty.sub("", text) 
-        return text
-    def functionname(self, text):
-        check1 = re.compile(r"^[^()=]*(\b\w+)\s*[(=]")
-        found = check1.match(text)
-        if found:
-            return found.group(1)
-        check2 = re.compile(r"^[^()=]*(\b\w+)\s*$")
-        found = check2.match(text)
-        if found:
-            return found.group(1)
-        return ""
-    def run(self, filename):
-        filetext = open(filename).read()
-        for line in self.process(filetext, filename):
-            print line
-    def process(self, filetext, filename=""):
-        for token, text in self.parse(filetext):
-            if token == FileInclude:
-                yield "## SOURCE " + filename.replace("../", "")
-                yield "    #" + text.replace("\n", "\n    ")
-            elif token == FileComment:
-                yield "## INTRODUCTION"
-                yield self.commentblock(text)
-            elif token == FunctionPrototype:
-                name = self.functionname(text)
-                yield "-----------------------------------------"
-                yield "### " + name
-                yield "#### NAME"
-                yield "    " + name
-                yield "#### SYNOPSIS"
-                yield self.functionblock(text)
-            elif token == FunctionComment:
-                if text:
-                    yield "#### DESCRIPTION"
-                    yield self.commentblock(text)
-            else:
-                if text:
-                    yield "#### NOTES"
-                    print token, text.replace("\n", "\n  ")
-    def isexported_function(self):
-        function = self.function_text.strip().replace("\n"," ")
-        logg.debug("@ --------------------------------------") 
-        logg.debug("@ ALLDEFINITIONS %s", self.alldefinitions)
-        if function.startswith("static ") and self.alldefinitions < 3:
-            logg.debug("@ ONLY INTERNAL %s", function)
-            return False
-        if not self.comment_text:
-            if not self.alldefinitions:
-                logg.info("@ NO COMMENT ON %s", function)
-                return False
-            else:
-                logg.warn("@ NO COMMENT ON %s", function)
-        text = self.comment_text
-        if text.startswith("/**"): return True
-        if text.startswith("/*!"): return True
-        if text.startswith("///"): return True
-        if text.startswith("//!"): return True
-        if self.alldefinitions >= 1:
-            if text.startswith("/*"): return True
-            if text.startswith("//"): return True
-        if self.alldefinitions >= 2:
-            return True
-        logg.debug("@ NO ** COMMENT %s", self.function_text.strip())
-        defs = self.function_text
-        return False
-    def parse(self, filetext):
-        c = lexer.CLexer()
-        for token, text in c.get_tokens(filetext):
-            logg.debug("|| %s %s", token, text.replace("\n", "\n |"))
-            # completion
-            if token != Token.Comment.Preproc and self.fileinclude_done == "no":
-                    yield FileInclude, self.fileinclude_text
-                    if self.filecomment_text:
-                        yield FileComment, self.filecomment_text
-                    self.fileinclude_done = "done"
-            # parsing
-            if token == Token.Comment.Multiline:
-                if not self.filecomment_done:
-                    self.filecomment_done = "done"
-                    self.filecomment_text = text
-                    # wait until we know it is not a function documentation
-                    self.comment_text = text
-                else:
-                    self.comment_text = text
-            elif token == Token.Comment.Preproc and "include" in text:
-                if not self.fileinclude_done:
-                    self.fileinclude_done = "no"
-                    self.fileinclude_text += text
-                    self.comment_text = ""
-            elif token == Token.Comment.Preproc and self.fileinclude_done == "no":
-                if not "\n" in self.fileinclude_text:
-                    self.fileinclude_text += text
-                self.comment_text = ""
-            elif token == Token.Comment.Preproc:
-                    self.comment_text = ""
-                    self.function_text = ""
-            elif token == Token.Operator and text == "=":
-                if not self.nesting and self.function_text.strip():
-                    if self.isexported_function():
-                        yield FunctionPrototype, self.function_text
-                        yield FunctionComment, self.comment_text
-                self.comment_text = ""
-                self.function_text = ""
-            elif token == Token.Punctuation and text == ";":
-                self.comment_text = ""
-                self.function_text = ""
-            elif token == Token.Punctuation and text == "{":
-                if not self.nesting and self.function_text.strip():
-                    if self.isexported_function():
-                        yield FunctionPrototype, self.function_text
-                        yield FunctionComment, self.comment_text
-                self.comment_text = ""
-                self.function_text = ""
-                self.nesting += 1
-            elif token == Token.Punctuation and text == "}":
-                self.nesting -= 1
-                self.comment_text = ""
-                self.function_text = ""
-            else:
-                if not self.nesting:
-                    self.function_text += text
-                else:
-                    pass # yield "|",text
-                
-
-if __name__ == "__main__":
-    _o = optparse.OptionParser()
-    _o.add_option("-v", "--verbose", action="count", default=0)
-    _o.add_option("-a", "--all", action="count", default=0,
-                  help="include all definitions in the output (not only /**)")
-    opt, args = _o.parse_args()
-
-    logg.addHandler(logging.StreamHandler())
-    if opt.verbose:
-        logg.setLevel(logging.WARN - 10 * opt.verbose)
-    
-    c = CppToMarkdown()
-    if opt.all:
-        c.alldefinitions = opt.all
-    for arg in args:
-        c.run(arg)
-    
-    
-
-
diff --git a/docs/dbk2man.py b/docs/dbk2man.py
index 33eb905..d6a91fd 100755
--- a/docs/dbk2man.py
+++ b/docs/dbk2man.py
@@ -16,11 +16,14 @@
 
 logg = logging.getLogger("dbk2man")
 
+
 def esc(text):
     text = str(text)
     text = text.replace(".", "\\&.")
     text = text.replace("-", "\\-")
     return text
+
+
 def unescape(text):
     text = str(text)
     text = text.replace('&lt;', '<')
@@ -28,6 +31,8 @@ def unescape(text):
     text = text.replace('&quot;', '"')
     text = text.replace('&amp;', '&')
     return text
+
+
 def htm(text):
     text = str(text)
     text = text.replace('&', '&amp;')
@@ -35,24 +40,32 @@ def htm(text):
     text = text.replace('>', '&gt;')
     text = text.replace('"', '&quot;')
     return text
+
+
 def mailhref(text):
-    return re.sub("<([^<>]*@[^<>]*)>", 
-        lambda x: '&lt;<a href="mailto:%s">%s</a>&gt;' % (x.group(1), x.group(1)), 
-        text)
+    return re.sub("<([^<>]*@[^<>]*)>",
+                  lambda x: '&lt;<a href="mailto:%s">%s</a>&gt;' % (
+                      x.group(1), x.group(1)),
+                  text)
+
+
+OverviewEntry = collections.namedtuple("OverviewEntry",
+                                       ["manpage", "manvolnum", "refpurpose"])
 
-OverviewEntry = collections.namedtuple("OverviewEntry", ["manpage", "manvolnum", "refpurpose"])
 
 def parse_docbook(filename):
     tree = ET.parse(filename)
     return tree.getroot()
 
-def dbk2(man, filenames, subdirectory = "."):
+
+def dbk2(man, filenames, subdirectory="."):
     for filename in filenames:
         root = parse_docbook(filename)
         overview = docbook2(man, root, subdirectory)
         overview2(man, overview, subdirectory, filename)
 
-def docbook2(man, root, subdirectory = "."):
+
+def docbook2(man, root, subdirectory="."):
     if root.tag != "reference":
         logg.warning("no <reference> found, not a docbook file?")
         logg.warning("found <%s> instead", root.tag)
@@ -71,67 +84,77 @@ def docbook2(man, root, subdirectory = "."):
             overview[filename] = overviewentry
     return overview
 
+
 def refentryinfo2(man, refentry, title):
     date, productname, manvolnum, refentrytitle = "", "", "", ""
     section = refentry.find("refentryinfo")
     if section is not None:
         found = section.find("date")
-        if found is not None: date = found.text
+        if found is not None:
+            date = found.text
         found = section.find("productname")
-        if found is not None: productname = found.text
+        if found is not None:
+            productname = found.text
     section = refentry.find("refmeta")
     if section is not None:
         found = section.find("refentrytitle")
-        if found is not None: refentrytitle = found.text
+        if found is not None:
+            refentrytitle = found.text
         found = section.find("manvolnum")
-        if found is not None: manvolnum = found.text
+        if found is not None:
+            manvolnum = found.text
     if man:
         header = []
         if refentrytitle:
-            header += [ refentrytitle ]
+            header.append(refentrytitle)
             if manvolnum:
-                header += [ manvolnum ]
+                header.append(manvolnum)
                 if date:
-                    header += [ date ]
+                    header.append(date)
                     if productname:
-                        header += [ productname ]
+                        header.append(productname)
                     if title:
-                        header += [ title ]
+                        header.append(title)
         if not header:
             logg.warning("no <refmeta> found")
             return ""
-        text = '.TH ' + " ".join([ '"%s"' % esc(part) for part in header])
+        text = '.TH ' + " ".join(['"%s"' % esc(part) for part in header])
         return text + "\n"
     else:
         text = "<html><head><title>"
-        if productname or title: 
+        if productname or title:
             text += "%s: " % htm(productname or title)
         text += htm(refentrytitle)
-        if manvolnum: 
+        if manvolnum:
             text += "(%s)" % htm(manvolnum)
         text += "</title>"
-        text += "\n" + '<meta name="product" content="%s" />' % htm(productname or title)
-        text += "\n" + '<meta name="refentry" content="%s" />' % htm(refentrytitle)
+        text += "\n" + '<meta name="product" content="%s" />' % htm(
+            productname or title)
+        text += "\n" + '<meta name="refentry" content="%s" />' % htm(
+            refentrytitle)
         text += "\n" + '<meta name="manvolnum" content="%s" />' % htm(manvolnum)
         text += "\n" + '<meta name="date" content="%s" />' % htm(date)
         return text + "\n</head><body>\n"
 
-def refentrytitle2(man, refentry, title = ""):
+
+def refentrytitle2(man, refentry):
     refentrytitle = ""
     section = refentry.find("refmeta")
     if section is not None:
         found = section.find("refentrytitle")
-        if found is not None: refentrytitle = found.text
-    refentries = [ refentrytitle ]
+        if found is not None:
+            refentrytitle = found.text
+    refentries = [refentrytitle]
     refpurpose = ""
     section = refentry.find("refnamediv")
     if section is not None:
         found = section.find("refpurpose")
-        if found is not None: refpurpose = found.text
+        if found is not None:
+            refpurpose = found.text
         for found in section.findall("refname"):
-             refname = found.text
-             if refname not in refentries:
-                 refentries.append(refname)
+            refname = found.text
+            if refname not in refentries:
+                refentries.append(refname)
     if not refentrytitle:
         logg.warning("no <refentrytitle> found")
         return ""
@@ -149,24 +172,27 @@ def refentrytitle2(man, refentry, title = ""):
         text += "</p>"
         return text + "\n"
 
-def refsynopsisdiv2(man, refentry, title = ""):
+
+def refsynopsisdiv2(man, refentry):
     refsynopsisdiv = refentry.find("refsynopsisdiv")
     if refsynopsisdiv is None:
         logg.warning("no <resynopsisdiv> found")
         return ""
     if man:
-        return refsynopsisdiv2man(refsynopsisdiv, title)
+        return refsynopsisdiv2man(refsynopsisdiv)
     else:
-        return refsynopsisdiv2htm(refsynopsisdiv, title)
+        return refsynopsisdiv2htm(refsynopsisdiv)
 
-def refsynopsisdiv2man(refsynopsisdiv, title = ""):
+
+def refsynopsisdiv2man(refsynopsisdiv):
     text = '.SH "SYNOPSIS"' + "\n"
     text += ".sp\n"
     text += ".nf\n"
     for funcsynopsis in refsynopsisdiv.findall("funcsynopsis"):
         funcsynopsisinfo = ""
         found = funcsynopsis.find("funcsynopsisinfo")
-        if found is not None: funcsynopsisinfo = found.text
+        if found is not None:
+            funcsynopsisinfo = found.text
         if funcsynopsisinfo:
             for info in funcsynopsisinfo.split("\n"):
                 text += '.B "%s"' % esc(info)
@@ -179,22 +205,14 @@ def refsynopsisdiv2man(refsynopsisdiv, title = ""):
         for funcprototype in funcsynopsis.findall("funcprototype"):
             item = ET.tostring(funcprototype)
             item = str(item)
-            item = item.replace("<funcprototype>","")
-            item = item.replace("</funcprototype>","")
-            if False:
-                item = item.replace("\n", " ")
-                item = item.replace("<funcdef>","")
-                item = item.replace("</funcdef>","")
-                item = item.replace("<paramdef>",'<def>')
-                item = item.replace("</paramdef>",'<def>')
-                items = item.split("<def>")
-                text += '.BI %s' % " ".join(['"%s"' % part for part in items if part])
-            else:
-                item = item.replace("<funcdef>","")
-                item = re.sub(r"([_\w]+)</funcdef>", lambda x: "\\fI%s\\fR" % x.group(1), item)
-                item = item.replace("<paramdef>",'')
-                item = item.replace("</paramdef>",'')
-                text += item 
+            item = item.replace("<funcprototype>", "")
+            item = item.replace("</funcprototype>", "")
+            item = item.replace("<funcdef>", "")
+            item = re.sub(r"([_\w]+)</funcdef>",
+                          lambda x: "\\fI%s\\fR" % x.group(1), item)
+            item = item.replace("<paramdef>", '')
+            item = item.replace("</paramdef>", '')
+            text += item
             text += "\n"
             funcs += 1
         if not funcs:
@@ -204,13 +222,15 @@ def refsynopsisdiv2man(refsynopsisdiv, title = ""):
         text += ".sp" + "\n"
     return text
 
-def refsynopsisdiv2htm(refsynopsisdiv, title = ""):
+
+def refsynopsisdiv2htm(refsynopsisdiv):
     text = '<h3>Synopsis</h3>' + "\n"
     text += '<pre>' + "\n"
     for funcsynopsis in refsynopsisdiv.findall("funcsynopsis"):
         funcsynopsisinfo = ""
         found = funcsynopsis.find("funcsynopsisinfo")
-        if found is not None: funcsynopsisinfo = found.text
+        if found is not None:
+            funcsynopsisinfo = found.text
         if funcsynopsisinfo:
             for info in funcsynopsisinfo.split("\n"):
                 text += '<b>%s</b>' % htm(info)
@@ -223,13 +243,14 @@ def refsynopsisdiv2htm(refsynopsisdiv, title = ""):
         for funcprototype in funcsynopsis.findall("funcprototype"):
             item = ET.tostring(funcprototype)
             item = str(item)
-            item = item.replace("<funcprototype>","")
-            item = item.replace("</funcprototype>","")
-            item = item.replace("<funcdef>","")
-            item = re.sub(r"([_\w]+)</funcdef>", lambda x: "<b>%s</b>" % x.group(1), item)
-            item = item.replace("<paramdef>",'')
-            item = item.replace("</paramdef>",'')
-            text += item 
+            item = item.replace("<funcprototype>", "")
+            item = item.replace("</funcprototype>", "")
+            item = item.replace("<funcdef>", "")
+            item = re.sub(r"([_\w]+)</funcdef>",
+                          lambda x: "<b>%s</b>" % x.group(1), item)
+            item = item.replace("<paramdef>", '')
+            item = item.replace("</paramdef>", '')
+            text += item
             text += "\n"
             funcs += 1
         if not funcs:
@@ -238,23 +259,24 @@ def refsynopsisdiv2htm(refsynopsisdiv, title = ""):
         text += "</pre>" + "\n"
     return text
 
-def refsections2(man, refentry, title = ""):
+
+def refsections2(man, refentry):
     text = ""
     for refsect in refentry.findall("refsect1"):
         if man:
-            text += refsect2man(refsect, title)
+            text += refsect2man(refsect)
             text += ".sp\n"
         else:
-            text += refsect2htm(refsect, title)
+            text += refsect2htm(refsect)
     return text
 
 
-def refsect2man(refsect, title = ""):
+def refsect2man(refsect):
     text = ""
     head = refsect.find("title")
     if head is not None:
-       text += '.SH "%s"' % (esc(head.text.upper()))
-       text += "\n"
+        text += '.SH "%s"' % (esc(head.text.upper()))
+        text += "\n"
     for para in list(refsect):
         if para.tag == 'title':
             continue
@@ -270,12 +292,13 @@ def refsect2man(refsect, title = ""):
         logg.warning("unknown para <%s>", para.tag)
     return text
 
-def refsect2htm(refsect, title = ""):
+
+def refsect2htm(refsect):
     text = ""
     head = refsect.find("title")
     if head is not None:
-       text += '<h3>%s</h3>' % htm(head.text)
-       text += "\n"
+        text += '<h3>%s</h3>' % htm(head.text)
+        text += "\n"
     for para in list(refsect):
         if para.tag == 'title':
             continue
@@ -293,73 +316,78 @@ def refsect2htm(refsect, title = ""):
         logg.warning("unknown para <%s>", para.tag)
     return text
 
+
 def para2man(para):
-   item = unescape(ET.tostring(para))
-   item = str(item)
-   item = item.replace("\n", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("<listitem>", "")
-   item = item.replace("</listitem>", "")
-   item = item.replace("<para>", "")
-   item = item.replace("</para>", "")
-   item = item.replace("<function>", "\\fI")
-   item = item.replace("</function>", "\\fP")
-   item = item.replace("<literal>", "\\fI")
-   item = item.replace("</literal>", "\\fP")
-   return item
+    item = unescape(ET.tostring(para))
+    item = str(item)
+    item = item.replace("\n", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("<listitem>", "")
+    item = item.replace("</listitem>", "")
+    item = item.replace("<para>", "")
+    item = item.replace("</para>", "")
+    item = item.replace("<function>", "\\fI")
+    item = item.replace("</function>", "\\fP")
+    item = item.replace("<literal>", "\\fI")
+    item = item.replace("</literal>", "\\fP")
+    return item
+
 
 def para2htm(para):
-   item = unescape(ET.tostring(para))
-   item = str(item)
-   item = item.replace("\n", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("  ", " ")
-   item = item.replace("<listitem>", "")
-   item = item.replace("</listitem>", "")
-   item = item.replace("<para>", "")
-   item = item.replace("</para>", "")
-   item = item.replace("<function>", "<em><code>")
-   item = item.replace("</function>", "</code></em>")
-   item = item.replace("<literal>", "<code>")
-   item = item.replace("</literal>", "</code>")
-   item = mailhref(item)
-   return item
+    item = unescape(ET.tostring(para))
+    item = str(item)
+    item = item.replace("\n", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("  ", " ")
+    item = item.replace("<listitem>", "")
+    item = item.replace("</listitem>", "")
+    item = item.replace("<para>", "")
+    item = item.replace("</para>", "")
+    item = item.replace("<function>", "<em><code>")
+    item = item.replace("</function>", "</code></em>")
+    item = item.replace("<literal>", "<code>")
+    item = item.replace("</literal>", "</code>")
+    item = mailhref(item)
+    return item
+
 
 def styleinfo2(man):
     if man:
         styles = []
-        styles += [ ".ie \\n(.g .ds Aq \\(aq" ]
-        styles += [ ".el        .ds Aq " ] # http://bugs.debian.org/507673
-        styles += [ ".nh" ] # disable hyphenation
-        styles += [ ".ad l" ] # align left, no justification
-        return "".join([ "%s\n" % part for part in styles ])
+        styles += [".ie \\n(.g .ds Aq \\(aq"]
+        styles += [".el        .ds Aq "]  # http://bugs.debian.org/507673
+        styles += [".nh"]  # disable hyphenation
+        styles += [".ad l"]  # align left, no justification
+        return "".join(["%s\n" % part for part in styles])
     else:
         return ""
 
+
 def refends2(man):
     if man:
         return ""
     else:
         return "</body></html>" + "\n"
 
-def refentry2(man, refentry, subdirectory = ".", title = ""):
+
+def refentry2(man, refentry, subdirectory=".", title=""):
     if refentry.tag != "refentry":
         logg.warning("no <refentry> found, not a docbook file?")
         logg.warning("found <%s> instead", refentry.tag)
     text = ""
     text += refentryinfo2(man, refentry, title)
     text += styleinfo2(man)
-    text += refentrytitle2(man, refentry, title)
+    text += refentrytitle2(man, refentry)
     text += refsynopsisdiv2(man, refentry)
     text += refsections2(man, refentry)
     text += refends2(man)
 
-    ### write the files
+    # write the files
     refentrytitle = ""
     manvolnum = "3"
     section = refentry.find("refmeta")
@@ -368,25 +396,29 @@ def refentry2(man, refentry, subdirectory = ".", title = ""):
         if found is not None: refentrytitle = found.text
         found = section.find("manvolnum")
         if found is not None: manvolnum = found.text
-    #
+
     refpurpose = ""
     section = refentry.find("refnamediv")
     if not section:
-        logg.warning("no <refnamediv> found in <refentry> for '%s', bad docbook?", refentrytitle)
+        logg.warning(
+            "no <refnamediv> found in <refentry> for '%s', bad docbook?",
+            refentrytitle)
         if not refentrytitle: raise Exception("not even a refentrytitle")
-        manpages = [ refentrytitle ]
+        manpages = [refentrytitle]
     else:
-        manpages = [ refname.text for refname in section.findall("refname") ]
+        manpages = [refname.text for refname in section.findall("refname")]
         found = section.find("refpurpose")
-        if found is not None: refpurpose = found.text
-    #
+        if found is not None:
+            refpurpose = found.text
+
     overview = {}
     if man:
         written = 0
         for manpage in manpages:
             if not refentrytitle:
                 refentrytitle = manpage
-            filename = "%s/man%s/%s.%s" % (subdirectory, manvolnum, manpage, manvolnum)
+            filename = "%s/man%s/%s.%s" % (
+                subdirectory, manvolnum, manpage, manvolnum)
             if manpage != refentrytitle:
                 manpagetext = ".so %s.%s\n" % (refentrytitle, manvolnum)
                 writefile(filename, manpagetext)
@@ -397,7 +429,8 @@ def refentry2(man, refentry, subdirectory = ".", title = ""):
             overview[filename] = OverviewEntry(manpage, manvolnum, refpurpose)
         if not written:
             manpage = refentrytitle
-            filename = "%s/man%s/%s.%s" % (subdirectory, manvolnum, manpage, manvolnum)
+            filename = "%s/man%s/%s.%s" % (
+                subdirectory, manvolnum, manpage, manvolnum)
             writefile(filename, manpagetext)
             overview[filename] = OverviewEntry(manpage, manvolnum, refpurpose)
     else:
@@ -405,34 +438,40 @@ def refentry2(man, refentry, subdirectory = ".", title = ""):
         filename = "%s/%s.%s.%s" % (subdirectory, manpage, manvolnum, "html")
         writefile(filename, text)
         overview[filename] = OverviewEntry(manpage, manvolnum, refpurpose)
-    #
+
     return overview
 
+
 def splitname(filename):
     base = os.path.basename(filename)
     name, ext = os.path.splitext(base)
     return name
 
+
 def overview2(man, overview, subdirectory, docbook_filename):
     if not man:
         overview2htm(overview, subdirectory, docbook_filename)
 
+
 def overview2htm(overview, subdirectory, docbook_filename):
     basename = splitname(docbook_filename)
-    text = "<html><head><title>%s %s</title>\n" % (htm(basename), htm("overview"))
+    text = "<html><head><title>%s %s</title>\n" % (
+        htm(basename), htm("overview"))
     text += "</head><body>\n"
     text += "<h3>%s %s</h3>\n" % (htm(basename), htm("overview"))
     text += "<ul>\n"
     for filename in sorted(overview):
         entry = overview[filename]
         subdir_filename = os.path.basename(filename)
-        text += '<li><a href="%s">%s</a> - %s</li>' % (subdir_filename, entry.manpage, htm(entry.refpurpose))
+        text += '<li><a href="%s">%s</a> - %s</li>' % (
+            subdir_filename, entry.manpage, htm(entry.refpurpose))
         text += "\n"
     text += "</ul>\n"
     text += "</body></html>\n"
     filename = "%s/%s.%s" % (subdirectory, basename, "html")
     writefile(filename, text)
 
+
 def writefile(filename, manpagetext):
     dirname = os.path.dirname(filename)
     if not os.path.isdir(dirname):
@@ -442,20 +481,22 @@ def writefile(filename, manpagetext):
         f.write(manpagetext)
     logg.debug("written %s [%s]", filename, manpagetext.split("\n", 1)[0])
 
+
 if __name__ == "__main__":
     from optparse import OptionParser
+
     _o = OptionParser("%prog [options] docbookfiles...")
-    _o.add_option("-o","--into", metavar="DIR", default=".",
-        help="specify base directory for output [%default]")
-    _o.add_option("-t","--make", metavar="DIR", default="man",
-        help="make 'man'/'html' output pages [%default]")
-    _o.add_option("-v","--verbose", action="count", default=0,
-        help="increase logging level [%default]")
+    _o.add_option("-o", "--into", metavar="DIR", default=".",
+                  help="specify base directory for output [%default]")
+    _o.add_option("-t", "--make", metavar="DIR", default="man",
+                  help="make 'man'/'html' output pages [%default]")
+    _o.add_option("-v", "--verbose", action="count", default=0,
+                  help="increase logging level [%default]")
     opt, args = _o.parse_args()
-    logging.basicConfig(level = max(0, logging.WARNING - 10 * opt.verbose))
+    logging.basicConfig(level=max(0, logging.WARNING - 10 * opt.verbose))
     # ensure commandline is compatible with "xmlto -o DIR TYPE INPUTFILE"
     make = opt.make
     if args and args[0] in ("man", "html"):
-       make = args[0]
-       args = args[1:]
+        make = args[0]
+        args = args[1:]
     dbk2(make == 'man', args, opt.into)
diff --git a/docs/dir2index.py b/docs/dir2index.py
index dea1c2e..f4c4d2a 100755
--- a/docs/dir2index.py
+++ b/docs/dir2index.py
@@ -9,35 +9,17 @@
 import logging
 import os.path
 import re
-import xml.etree.ElementTree as ET
 
 logg = logging.getLogger("dir2index")
 
-def esc(text):
-    text = text.replace(".", "\\&.")
-    text = text.replace("-", "\\-")
-    return text
-def unescape(text):
-    text = text.replace('&lt;', '<')
-    text = text.replace('&gt;', '>')
-    text = text.replace('&quot;', '"')
-    text = text.replace('&amp;', '&')
-    return text
-def htm(text):
-    text = text.replace('&', '&amp;')
-    text = text.replace('<', '&lt;')
-    text = text.replace('>', '&gt;')
-    text = text.replace('"', '&quot;')
-    return text
+
 def splitname(filename):
     base = os.path.basename(filename)
     name, ext = os.path.splitext(base)
-    if name.endswith(".3"): name = name[:-2]
+    if name.endswith(".3"):
+        name = name[:-2]
     return name
 
-def parse_html(filename):
-    tree = ET.parse(filename)
-    return tree.getroot()
 
 def zzip_sorted(filenames):
     for name in filenames:
@@ -47,7 +29,8 @@ def zzip_sorted(filenames):
         if "zziplib" not in name:
             yield name
 
-def dir2(man, dirs, into):
+
+def dir2(dirs, into):
     text = "<html><body>" + "\n"
     file2name = {}
     file2text = {}
@@ -95,6 +78,7 @@ def dir2(man, dirs, into):
     text += "</body></html>" + "\n"
     writefile("%s/index.html" % into, text)
 
+
 def writefile(filename, manpagetext):
     dirname = os.path.dirname(filename)
     if not os.path.isdir(dirname):
@@ -104,17 +88,18 @@ def writefile(filename, manpagetext):
         f.write(manpagetext)
     logg.debug("written %s [%s]", filename, manpagetext.split("\n", 1)[0])
 
+
 if __name__ == "__main__":
     from optparse import OptionParser
+
     _o = OptionParser("%prog [options] directories...")
-    _o.add_option("-o","--into", metavar="DIR", default=".",
-        help="specify base directory for output [%default]")
-    _o.add_option("-t","--make", metavar="DIR", default="man",
-        help="make 'man'/'html' output pages [%default]")
-    _o.add_option("-v","--verbose", action="count", default=0,
-        help="increase logging level [%default]")
+    _o.add_option("-o", "--into", metavar="DIR", default=".",
+                  help="specify base directory for output [%default]")
+    _o.add_option("-t", "--make", metavar="DIR", default="man",
+                  help="make 'man'/'html' output pages [%default]")
+    _o.add_option("-v", "--verbose", action="count", default=0,
+                  help="increase logging level [%default]")
     opt, args = _o.parse_args()
-    logging.basicConfig(level = max(0, logging.WARNING - 10 * opt.verbose))
+    logging.basicConfig(level=max(0, logging.WARNING - 10 * opt.verbose))
     # ensure commandline is compatible with "xmlto -o DIR TYPE INPUTFILE"
-    make = opt.make
-    dir2(make == 'man', args, opt.into)
+    dir2(args, opt.into)
diff --git a/docs/make-doc.py b/docs/make-doc.py
deleted file mode 100644
index 1f8ff0c..0000000
--- a/docs/make-doc.py
+++ /dev/null
@@ -1,1028 +0,0 @@
-#! /usr/bin/python
-# -*- coding: UTF-8 -*-
-import sys
-import re
-import string
-import commands
-import warnings
-
-errors = 0
-def warn(msg, error=None):
-    global errors
-    errors += 1
-    if error is None:
-        warnings.warn("-- "+str(errors)+" --\n  "+msg, RuntimeWarning, 2)
-    else:
-        warnings.warn("-- "+str(errors)+" --\n  "+msg+
-                      "\n  error was "+str(error), RuntimeWarning, 2)
-#fu
-
-# beware, stupid python interprets backslashes in repl only partially!
-def s(string, pattern, repl, count=0):
-    return re.sub(pattern, repl, string, count)
-def m(string, pattern):
-    return re.match(pattern, string)
-def sorted_keys(dict):
-    keys = dict.keys()
-    keys.sort()
-    return keys
-
-# we make up a few formatter routines to help in the processing:
-def html2docbook(text):
-    """ the C comment may contain html markup - simulate with docbook tags """
-    return (
-        s(s(s(s(s(s(s(s(s(s(s(text,
-                              r"<br\s*/?>",""),
-                            r"(</?)em>",r"\1emphasis>"),
-                          r"<code>","<userinput>"),
-                        r"</code>","</userinput>"),
-                      r"<link>","<function>"),
-                    r"</link>","</function>"),
-                  r"(?s)\s*</screen>","</screen>"),
-#               r"<ul>","</para><itemizedlist>"),
-#             r"</ul>","</itemizedlist><para>"),
-#           r"<li>","<listitem><para>"),
-#         r"</li>","</para></listitem>\n"),
-                r"<ul>","</para><programlisting>\n"),
-              r"</ul>","</programlisting><para>"),
-            r"<li>",""),
-          r"</li>",""))
-def paramdef2html(text):
-    return s(s(s(s(s(text,
-                     r"\s+<paramdef>", r"\n<nobr>"),
-                   r"<paramdef>",r"<nobr>"),
-                 r"</paramdef>",r"</nobr>"),
-               r"<parameters>",r"\n <code>"),
-             r"</parameters>",r"</code>\n")
-def section2html(text):
-    mapping = { "<screen>" : "<pre>", "</screen>" : "</pre>",
-                "<para>" : "<p>", "</para>" : "</p>" ,
-                "<function>" : "<link>", "</function>" : "</link>" }
-    for str in mapping:
-        text = string.replace(text, str, mapping[str])
-    return text
-def html(text):
-    return section2html(paramdef2html(text))
-def cdata1(text):
-    return string.replace(text, "&",  "&amp;")
-def cdata31(text):
-    return string.replace(string.replace(text, "<","&lt;"), ">","&gt;")
-def cdata3(text):
-    return cdata31(cdata1(text))
-def cdata43(text):
-    return string.replace(text,"\"", "&quot;")
-def cdata41(text):
-    return cdata43(cdata31(text))
-def cdata4(text):
-    return cdata43(cdata3(text))
-def markup_as_screen41 (text):
-    """ used for non-star lines in comment blocks """
-    return " <screen> " + s(cdata41(text), r"(?m)^", r" ") +" </screen> "
-
-def file_comment2section(text):
-    """ convert a C comment into a series of <para> and <screen> parts """
-    return ("<para>\n"+
-            s(s(s(s(s(s(s(text,
-                          r"(?s){<([\w\.\-]+\@[\w\.\-]+\w\w)>",
-                          r"&lt;\1&gt;"),
-                        r"(?mx) ^\s?\s?\s? ([^\*\s]+ .*) $",
-                        lambda x : markup_as_screen41 (x.group(1))),
-                      r"(?mx) ^\s*[*]\s* $", r" \n</para><para>\n"),
-                    r"(?mx) ^\s?\s?\s?\* (.*) $", r" \1 "),
-                  r"(?sx) </screen>(\s*)<screen> ", r"\1"),
-                r"(?sx) <([^<>\;]+\@[^<>\;]+)> ", r"<email>\1</email>"),
-              r"(?sx) \&lt\;([^<>\&\;]+\@[^<>\&\;]+)\&gt\; ",
-              r"<email>\1</email>") + "\n</para>")
-def func_comment2section(text):
-    """ convert a C comment into a series of <para> and <screen> parts
-        and sanitize a few markups already present in the comment text
-    """
-    return ("<para>\n"+
-            s(s(s(s(s(s(s(s(s(s(s(text,
-                                  r"<c>",r"<code>"),   r"</c>", r"</code>"),
-                              r"(?mx) ^\s?\s?\s? ([^\*\s]+.*)",
-                              lambda x: markup_as_screen41 (x.group(1))),
-                            r"(?mx) ^\s?\s?\s?\* (.*) $", r" <br /> \1"),
-                          r"(?mx) ^\s*<br\s*\/>\s* $", r"\n</para><para>\n"),
-                        r"<<",r"&lt;"),   r">>",r"&gt;"),
-                    r"(?sx) (</?para>\s*)<br\s*\/?>",r"\1"),
-                  r"(?sx) (</?para>\s*)<br\s*\/?>",r"\1"),
-                r"(?sx) (<br\s*\/?>\s*)<br\s*\/?>",r"\1"),
-              r"(?sx) <\/screen>(\s*)<screen>",r"\1") + "\n</para>")
-def markup_link_syntax(text):
-    """ markup the link-syntax ` => somewhere ` in the text block """
-    return (
-        s(s(s(s(text,
-                r"(?mx) (^|\s)\=\>\"([^\"]*)\"", r"\1<link>\2</link>"),
-              r"(?mx) (^|\s)\=\>\'([^\"]*)\'", r"\1<link>\2</link>"),
-            r"(?mx) (^|\s)\=\>\s(\w[\w.]*\w)\b", r"\1<link>\2</link>"),
-          r"(?mx) (^|\s)\=\>\s([^\s\,\.\!\?\:\;\<\>\&\'\=\-]+)",
-          r"\1<link>\2</link>"))
-def this_function_link(text, name):
-    return s(text, r"(?sx) (T|t)his \s (function|procedure) ", lambda x
-             : "<function>"+x.group(1)+"he "+name+" "+x.group(2)+"</function>")
-
-# -----------------------------------------------------------------------
-class Options:
-    var = {}
-    def __getattr__(self, name):
-        if not self.var.has_key(name): return None
-        return self.var[name]
-    def __setattr__(self, name, value):
-        self.var[name] = value
-#end
-
-o = Options()
-o.verbose = 0
-
-o.version = s( commands.getoutput(
-    """ grep -i "^version *:" *.spec 2>/dev/null |
-        sed -e "s/[Vv]ersion *: *//" """),  r"\s*",r"")
-o.package = s(commands.getoutput(
-    """ grep -i "^name *:" *.spec 2>/dev/null |
-        sed -e "s/[Nn]ame *: *//" """),     r"\s*",r"")
-
-if not len(o.version):
-    o.version = commands.getoutput(""" date +%Y.%m.%d """)
-if not len(o.package):
-    o.package = "_project"
-
-o.suffix = "-doc3"
-o.mainheader = o.package+".h"
-
-class File:
-    def __init__(self, filename):
-        self.name = filename
-        self.mainheader = o.mainheader
-        self.authors = ""
-        self.copyright = ""
-    def __getattr__(self, name):
-        """ defend against program to break on uninited members """
-        if self.__dict__.has_key(name): return self.__dict__[name]
-        warn("no such member: "+name); return None
-    def set_author(self, text):
-        if self.authors:
-            self.authors += "\n"
-        self.authors += text
-        return text
-    def set_copyright(self, text):
-        self.copyright = text
-        return text
-
-class InputFiles:
-    """ for each set of input files we can create an object
-        it does correspond with a single html-output page and
-        a single docbook <reference> master page to be output
-    """
-    def __init__(self):
-        # the id will tell us in which order
-        # we did meet each function definition
-        self.id = 1000
-        self.files = [] # file_list
-        self.funcs = [] # func_list: of hidden class FuncDeclaration
-        self.file = None # current file
-    def new_File(self, name):
-        self.file = File(name)
-        self.files.append(self.file)
-        return self.file
-    def next_id(self):
-        id = self.id ; self.id += 1
-        return id
-    def add_function_declaration(self, comment, prototype):
-        class FuncDeclaration:    # note that both decl.comment and
-            pass                  # decl.prototype are in cdata1 format
-        func = FuncDeclaration()
-        func.file = self.file
-        func.comment = s(comment, # need to take out email-style markups
-                         r"<([\w\.\-]+\@[\w\.\-]+\w\w)>", r"&lt;\1&gt;")
-        func.prototype = prototype
-        func.id = all.next_id()
-        self.funcs.append(func)
-        # print id
-        return prototype
-
-def scan_options (options, list):
-    def encode(text):
-        return s(s(text, r"",  r"&#AC;"), r"\*/",r"")
-    def decode(text):
-        return s(text, r"", r"*/")
-
-    for name in options:
-        found = m(name, r"^(\w+)=(.*)")
-        if found:
-            o.var[found.group(1)] = found.group(2)
-            continue
-        #else
-        try:
-            input = open(name, "r")
-        except IOError as error:
-            warn(#...... (scan_options) ...............
-                "can not open input file: "+name, error)
-            continue
-        text = input.read() ; input.close()
-        text = encode (cdata1 (text))
-
-        file = list.new_File(name)
-        
-        # cut per-function comment block
-        text = s(text, r"(?x) [/][*][*](?=\s) ([^]+)  ([^\{\}\;\#]+) [\{\;]",
-                 lambda x : list.add_function_declaration(
-            decode(x.group(1)), decode(x.group(2))))
-
-        # cut per-file comment block
-        found = m(text, r"(?sx)  [/][*]+(?=\s) ([^]+)  "
-                  r"(?:\s*\#define\s*\S+)*"
-                  r"(\s*\#include\s*<[^<>]*>(?:\s*//[^\n]*)?)")
-        if found:
-            file.comment = decode(found.group(1))
-            file.include = cdata31(found.group(2))
-        else:
-            file.comment = None
-            file.include = None
-            found = m(text, r"(?sx)  ^ [/][*]+(?=\s) ([^]+)  ")
-            if found:
-                file.comment = decode(found.group(1))
-        #fi
-        # throw away the rest - further processing on memorized strings only
-
-    return None
-
-all = InputFiles()
-scan_options (sys.argv[1:], all)
-
-if not o.docbookfile:
-    o.docbookfile = o.package+o.suffix+".docbook"
-if not o.libhtmlfile:
-    o.libhtmlfile = o.package+o.suffix+".html"
-if not o.dumpdocfile:
-    o.dumpdocfile = o.package+o.suffix+".dxml"
-
-# ...........................................................................
-# check out information in the file.comment section
-
-def all_files_comment2section(list):
-    for file in list:
-        if file.comment is None: continue
-        file.section = file_comment2section(file.comment)
-    
-        file.section = s(
-            file.section, r"(?sx) \b[Aa]uthor\s*:(.*</email>) ", lambda x
-            : "<author>" + file.set_author(x.group(1)) + "</author>")
-        file.section = s(
-            file.section, r"(?sx) \b[Cc]opyright\s*:([^<>]*)</para> ",lambda x
-            : "<copyright>" + file.set_copyright(x.group(1)) + "</copyright>")
-        # if "file" in file.name: print >> sys.stderr, file.comment # 2.3
-    #od
-all_files_comment2section(all.files)
-
-# -----------------------------------------------------------------------
-
-class Function:
-    " <prespec>void* </><namespec>hello</><namespec> (int) const</callspec> "
-    def __init__(self):
-        self.prespec  = ""
-        self.namespec = ""
-        self.callspec = ""
-        self.name = ""
-#    def set(self, **defines):
-#        name = defines.keys()[0]
-#        self.__dict__[name] = defines[name]
-#        return defines[name]
-#    def cut(self, **defines):
-#        name = defines.keys()[0]
-#        self.__dict__[name] += defines[name]
-#        return ""
-    def __getattr__(self, name):
-        """ defend against program exit on members being not inited """
-        if self.__dict__.has_key(name): return self.__dict__[name]
-        warn("no such member: "+name); return None
-    def dict(self):
-        return self.__dict__
-    def dict_sorted_keys(self):
-        keys = self.__dict__.keys()
-        keys.sort()
-        return keys
-    def parse(self, prototype):
-        found = m(prototype, r"(?sx) ^(.*[^.]) \b(\w[\w.]*\w)\b (\s*\(.*) $ ")
-        if found:
-            self.prespec = found.group(1).lstrip()
-            self.namespec = found.group(2)
-            self.callspec = found.group(3).lstrip()
-            self.name = self.namespec.strip()
-            return self.name
-        return None
-
-# pass 1 of per-func strings ...............................................
-# (a) cut prototype into prespec/namespec/callspec
-# (b) cut out first line of comment as headline information
-# (c) sanitize rest of comment block into proper docbook formatted .body
-# 
-# do this while copying strings from all.funcs to function_list
-# and remember the original order in name_list
-
-def markup_callspec(text):
-    return (
-        s(s(s(s(s(text,
-                  r"(?sx) ^([^\(\)]*)\(", r"\1<parameters>(<paramdef>",1),
-                r"(?sx) \)([^\(\)]*)$", r"</paramdef>)</parameters>\1",1),
-              r"(?sx) , ", r"</paramdef>,<paramdef>"),
-            r"(?sx) <paramdef>(\s+) ", r"\1<paramdef>"),
-          r"(?sx) (\s+)</paramdef>", r"</paramdef>\1"))
-
-def parse_all_functions(func_list): # list of FunctionDeclarations
-    """ parse all FunctionDeclarations and create a list of Functions """
-    list = []
-    for func in all.funcs:
-        function = Function()
-        if not function.parse (func.prototype): continue
-
-        list.append(function)
-
-        function.body = markup_link_syntax(func.comment)
-        if "\n" not in function.body: # single-line comment is the head
-            function.head = function.body
-            function.body = ""
-        else: # cut comment in first-line and only keep the rest as descr body
-            function.head = s(function.body,  r"(?sx) ^([^\n]*\n).*",r"\1",1)
-            function.body = s(function.body,  r"(?sx)  ^[^\n]*\n",   r"",  1)
-        #fi
-        if m(function.head, r"(?sx) ^\s*$ "): # empty head line, autofill here
-            function.head = s("("+func.file.name+")", r"[.][.][/]", r"")
-
-        function.body = func_comment2section(function.body)
-        function.src = func # keep a back reference
-
-        # add extra docbook markups to callspec in $fn-hash
-        function.callspec = markup_callspec (function.callspec)
-    #od
-    return list
-function_list = parse_all_functions(all.funcs)
-
-def examine_head_anchors(func_list):
-    """ .into tells later steps which func-name is the leader of a man 
-        page and that this func should add its descriptions over there. """
-    for function in func_list:
-        function.into = None
-        function.seealso = None
-        
-        found = m(function.head, r"(?sx) ^ \s* <link>(\w[\w.]*\w)<\/link>")
-        # if found and found.group(1) in func_list.names:
-        if found and found.group(1):
-            function.into = found.group(1)
-
-        def set_seealso(f, value):
-            f.seealso = value
-            return value
-        function.head = s(function.head, r"(.*)also:(.*)", lambda x
-                          : set_seealso(function, x.group(2)) and x.group(1))
-        if function.seealso and None:
-            print "function[",function.name,"].seealso=",function.seealso
-examine_head_anchors(function_list)
-
-# =============================================================== HTML =====
-
-def find_by_name(func_list, name):
-    for func in func_list:
-        if func.name == name:
-            return func
-    #od
-    return None
-#fu
-
-class HtmlFunction:
-    def __init__(self, func):
-        self.src = func.src
-        self.into = func.into
-        self.name = func.name
-        self.toc_line = paramdef2html(
-            "  <td valign=\"top\"><code>"+func.prespec+"</code></td>\n"+
-            "  <td valign=\"top\">&nbsp;&nbsp;</td>\n"+
-            "  <td valign=\"top\"><a href=\"#"+func.name+"\">\n"+
-            "                       <code>"+func.namespec+"</code>"+
-            "  </a></td>\n"+
-            "  <td valign=\"top\">&nbsp;&nbsp;</td>\n"+
-            "  <td valign=\"top\">"+func.callspec+"</td>\n")
-        self.synopsis = paramdef2html(
-            "  <code>"+func.prespec+"</code>\n"+
-            "  <br /><b><code>"+func.namespec+"</code></b>\n"+
-            "   &nbsp; <code>"+func.callspec+"</code>\n")
-        self.anchor = "<a name=\""+func.name+"\" />"
-        self.section = "<para><em> &nbsp;"+func.head+"\n"+ \
-                       "\n</em></para>"+section2html(func.body)
-#class
-
-class HtmlFunctionFamily(HtmlFunction):
-    def __init__(page, func):
-        HtmlFunction.__init__(page, func)
-        page.toc_line_list = [ page.toc_line ]
-        # page.html_txt     = page.synopsis
-        page.synopsis_list = [ page.synopsis ]
-        page.anchor_list   = [ page.anchor ]
-        page.section_list  = [ this_function_link(page.section, func.name) ]
-
-def ensure_name(text, name):
-    adds = "<small><code>"+name+"</code></small> -"
-    match = r"(?sx) .*>[^<>]*\b" + name + r"\b[^<>]*<.*"
-    found = m(text, match)
-    if found: return text
-    found = m(text, r".*<p(ara)?>.*")
-    if found: return s(text, r"(<p(ara)?>)", r"\1"+adds, 1)
-    return adds+text
-
-def combined_html_pages(func_list):
-    """ and now add descriptions of non-leader entries (html-mode) """
-    combined = {}
-    
-    for func in func_list: # assemble leader pages
-        if func.into is not None: continue
-        combined[func.name] =  HtmlFunctionFamily(func)
-
-    for func in func_list: 
-        if func.into is None: continue
-        if func.into not in combined :
-            warn(#......... (combine_html_pages) ..............
-                "function '"+func.name+"'s into => '"+func.into+
-                "\n: no such target function: "+func.into)
-            combined[func.name] = HtmlFunctionFamily(func)
-            continue
-        #fi
-        page = HtmlFunction(func)
-        into = combined[func.into]
-        into.toc_line_list.append( page.toc_line )
-        into.anchor_list.append( page.anchor )
-        into.synopsis_list.append( page.synopsis )
-        into.section_list.append(
-            s(ensure_name(this_function_link(section2html( func.body ),
-                                             func.name), func.name),
-              r"(?sx) (</?para>\s*) <br\s*\/>", r"\1"))
-    return combined.values()
-html_pages = combined_html_pages(function_list)
-
-def html_resolve_links_on_page(text, list):
-    """ link ref-names of a page with its endpoint on the same html page"""
-    def html_link (name , extra):
-        """ make <link>s to <href> of correct target or make it <code> """
-        if find_by_name(list, name) is None:
-            return "<code>"+name+extra+"</code>"
-        else:
-            return "<a href=\"#"+name+"\"><code>"+name+extra+"</code></a>"
-    #fu html_link
-    return s(s(text, r"(?sx) <link>(\w+)([^<>]*)<\/link> ",
-               lambda x : html_link(x.group(1),x.group(2))),
-             r"(?sx) \-\> ", r"<small>-&gt;</small>") # just sanitize..
-#fu html_resolve_links
-
-class HtmlPage:
-    def __init__(self):
-        self.toc = ""
-        self.txt = ""
-        self.package = o.package
-        self.version = o.version
-    def page_text(self):
-        """ render .toc and .txt parts into proper <html> page """
-        T = ""
-        T += "<html><head>"
-        T += "<title>"+self.package+"autodoc documentation </title>"
-        T += "</head>\n<body>\n"
-        T += "\n<h1>"+self.package+" <small><small><i>- "+self.version
-        T += "</i></small></small></h1>"
-        T += "\n<table border=0 cellspacing=2 cellpadding=0>"
-        T +=  self.toc
-        T += "\n</table>"
-        T += "\n<h3>Documentation</h3>\n\n<dl>"
-        T += html_resolve_links_on_page(self.txt, function_list)
-        T += "\n</dl>\n</body></html>\n"
-        return T
-    def add_page_map(self, list):
-        """ generate the index-block at the start of the onepage-html file """
-        keys = list.keys()
-        keys.sort()
-        for name in keys:
-            self.toc += "<tr valign=\"top\">\n"+ \
-                        "\n</tr><tr valign=\"top\">\n".join(
-                list[name].toc_line_list)+"</tr>\n"
-            self.txt += "\n<dt>"+" ".join(list[name].anchor_list)
-            self.txt += "\n"+"\n<br />".join(list[name].synopsis_list)+"<dt>"
-            self.txt += "\n<dd>\n"+"\n".join(list[name].section_list)
-            self.txt += ("\n<p align=\"right\">"+
-                         "<small>("+list[name].src.file.name+")</small>"+
-                         "</p></dd>")
-    def add_page_list(self, functions):
-        """ generate the index-block at the start of the onepage-html file """
-        mapp = {}
-        for func in functions:
-            mapp[func.name] = func
-        #od
-        self.add_page_map(mapp)
-#end
-
-html = HtmlPage()
-# html.add_function_dict(Fn)
-# html.add_function_list(Fn.sort.values())
-html.add_page_list(html_pages)
-
-# and finally print the html-formatted output
-try:
-    F = open(o.libhtmlfile, "w")
-except IOError as error:
-    warn(# ............. open(o.libhtmlfile, "w") ..............
-        "can not open html output file: "+o.libhtmlfile, error)
-else:
-    print >> F, html.page_text()
-    F.close()
-#fi
-
-# ========================================================== DOCBOOK =====
-# let's go for the pure docbook, a reference type master for all man pages
-
-class RefPage:
-    def __init__(self, func):
-        """ initialize the fields needed for a man page entry - the fields are
-           named after the docbook-markup that encloses (!!) the text we store
-           the entries like X.refhint = "hello" will be printed therefore as
-           <refhint>hello</refhint>. Names with underscores are only used as
-           temporaries but they are memorized, perhaps for later usage. """
-        self.refhint = "\n<!--========= "+func.name+" (3) ===========-->\n"
-        self.refentry = None
-        self.refentry_date = o.version.strip()        # //refentryinfo/date
-        self.refentry_productname = o.package.strip() # //refentryinfo/prod*
-        self.refentry_title = None                    # //refentryinfo/title
-        self.refentryinfo = None                      # override
-        self.manvolnum = "3"                         # //refmeta/manvolnum
-        self.refentrytitle = None                    # //refmeta/refentrytitle
-        self.refmeta = None                          # override
-        self.refpurpose = None                       # //refnamediv/refpurpose
-        self.refname = None                          # //refnamediv/refname
-        self.refname_list = []
-        self.refnamediv = None                       # override
-        self.mainheader = func.src.file.mainheader
-        self.includes = func.src.file.include
-        self.funcsynopsisinfo = ""       # //funcsynopsisdiv/funcsynopsisinfo
-        self.funcsynopsis = None         # //funcsynopsisdiv/funcsynopsis
-        self.funcsynopsis_list = []
-        self.description = None
-        self.description_list = []
-        # optional sections
-        self.authors_list = []           # //sect1[authors]/listitem
-        self.authors = None              # override
-        self.copyright = None
-        self.copyright_list = []
-        self.seealso = None
-        self.seealso_list = []
-        if  func.seealso:
-            self.seealso_list.append(func.seealso)
-        # func.func references
-        self.func = func
-        self.file_authors = None
-        if  func.src.file.authors:
-            self.file_authors = func.src.file.authors
-        self.file_copyright = None
-        if  func.src.file.copyright:
-            self.file_copyright = func.src.file.copyright
-    #fu
-    def refentryinfo_text(page):
-        """ the manvol formatter wants to render a footer line and header line
-            on each manpage and such info is set in <refentryinfo> """
-        if page.refentryinfo:
-            return page.refentryinfo
-        if page.refentry_date and \
-           page.refentry_productname and \
-           page.refentry_title: return (
-            "\n <date>"+page.refentry_date+"</date>"+ 
-            "\n <productname>"+page.refentry_productname+"</productname>"+
-            "\n <title>"+page.refentry_title+"</title>")
-        if page.refentry_date and \
-           page.refentry_productname: return (
-            "\n <date>"+page.refentry_date+"</date>"+ 
-            "\n <productname>"+page.refentry_productname+"</productname>")
-        return ""
-    def refmeta_text(page):
-        """ the manvol formatter needs to know the filename of the manpage to
-            be made up and these parts are set in <refmeta> actually """
-        if page.refmeta:
-            return page.refmeta
-        if page.manvolnum and page.refentrytitle:
-            return (
-                "\n <refentrytitle>"+page.refentrytitle+"</refentrytitle>"+
-                "\n <manvolnum>"+page.manvolnum+"</manvolnum>")
-        if page.manvolnum and page.func.name:
-            return (
-                "\n <refentrytitle>"+page.func.name+"</refentrytitle>"+
-                "\n <manvolnum>"+page.manvolnum+"</manvolnum>")
-        return ""
-    def refnamediv_text(page):
-        """ the manvol formatter prints a header line with a <refpurpose> line
-            and <refname>'d functions that are described later. For each of
-            the <refname>s listed here, a mangpage is generated, and for each
-            of the <refname>!=<refentrytitle> then a symlink is created """
-        if page.refnamediv:
-            return page.refnamediv
-        if page.refpurpose and page.refname:
-            return ("\n <refname>"+page.refname+'</refname>'+
-                    "\n <refpurpose>"+page.refpurpose+" </refpurpose>")
-        if page.refpurpose and page.refname_list:
-            T = ""
-            for refname in page.refname_list:
-                T += "\n <refname>"+refname+'</refname>'
-            T += "\n <refpurpose>"+page.refpurpose+" </refpurpose>"
-            return T
-        return ""
-    def funcsynopsisdiv_text(page):
-        """ refsynopsisdiv shall be between the manvol mangemaent information
-            and the reference page description blocks """
-        T=""
-        if page.funcsynopsis:
-            T += "\n<funcsynopsis>"
-            if page.funcsynopsisinfo:
-                T += "\n<funcsynopsisinfo>"+    page.funcsynopsisinfo + \
-                     "\n</funcsynopsisinfo>\n"
-            T += page.funcsynopsis + \
-                 "\n</funcsynopsis>\n"
-        if page.funcsynopsis_list:
-            T += "\n<funcsynopsis>"
-            if page.funcsynopsisinfo:
-                T += "\n<funcsynopsisinfo>"+    page.funcsynopsisinfo + \
-                     "\n</funcsynopsisinfo>\n"
-            for funcsynopsis in page.funcsynopsis_list:
-                T += funcsynopsis
-            T += "\n</funcsynopsis>\n"
-        #fi
-        return T
-    def description_text(page):
-        """ the description section on a manpage is the main part. Here
-            it is generated from the per-function comment area. """
-        if page.description:
-            return page.description
-        if page.description_list:
-            T = ""
-            for description in page.description_list:
-                if not description: continue
-                T += description
-            if T: return T
-        return ""
-    def authors_text(page):
-        """ part of the footer sections on a manpage and a description of
-            original authors. We prever an itimizedlist to let the manvol
-            show a nice vertical aligment of authors of this ref item """
-        if page.authors:
-            return page.authors
-        if page.authors_list:
-            T = "<itemizedlist>"
-            previous=""
-            for authors in page.authors_list:
-                if not authors: continue
-                if previous == authors: continue
-                T += "\n <listitem><para>"+authors+"</para></listitem>"
-                previous = authors
-            T += "</itemizedlist>"
-            return T
-        if page.authors:
-            return page.authors
-        return ""
-    def copyright_text(page):
-        """ the copyright section is almost last on a manpage and purely
-            optional. We list the part of the per-file copyright info """
-        if page.copyright:
-            return page.copyright
-        """ we only return the first valid instead of merging them """
-        if page.copyright_list:
-            T = ""
-            for copyright in page.copyright_list:
-                if not copyright: continue
-                return copyright # !!!
-        return ""
-    def seealso_text(page):
-        """ the last section on a manpage is called 'SEE ALSO' usually and
-            contains a comma-separated list of references. Some manpage
-            viewers can parse these and convert them into hyperlinks """
-        if page.seealso:
-            return page.seealso
-        if page.seealso_list:
-            T = ""
-            for seealso in page.seealso_list:
-                if not seealso: continue
-                if T: T += ", "
-                T += seealso
-            if T: return T
-        return ""
-    def refentry_text(page, id=None):
-        """ combine fields into a proper docbook refentry """
-        if id is None:
-            id = page.refentry
-        if id:
-            T = '<refentry id="'+id+'">'
-        else:
-            T = '<refentry>' # this is an error
-           
-        if page.refentryinfo_text():
-            T += "\n<refentryinfo>"+       page.refentryinfo_text()+ \
-                 "\n</refentryinfo>\n"
-        if page.refmeta_text():
-            T += "\n<refmeta>"+            page.refmeta_text() + \
-                 "\n</refmeta>\n" 
-        if page.refnamediv_text():
-            T += "\n<refnamediv>"+         page.refnamediv_text() + \
-                 "\n</refnamediv>\n"
-        if page.funcsynopsisdiv_text():     
-            T += "\n<refsynopsisdiv>\n"+   page.funcsynopsisdiv_text()+ \
-                 "\n</refsynopsisdiv>\n"
-        if page.description_text():
-            T += "\n<refsect1><title>Description</title> " + \
-                 page.description_text() + "\n</refsect1>"
-        if page.authors_text():
-            T += "\n<refsect1><title>Author</title> " + \
-                 page.authors_text() + "\n</refsect1>"
-        if page.copyright_text():
-            T += "\n<refsect1><title>Copyright</title> " + \
-                 page.copyright_text() + "\n</refsect1>\n"
-        if page.seealso_text():
-            T += "\n<refsect1><title>See Also</title><para> " + \
-                 page.seealso_text() + "\n</para></refsect1>\n"
-
-        T +=  "\n</refentry>\n"
-        return T
-    #fu
-#end
-
-# -----------------------------------------------------------------------
-class FunctionRefPage(RefPage):
-    def reinit(page):
-        """ here we parse the input function for its values """
-        if page.func.into:
-            page.refhint = "\n              <!-- see "+page.func.into+" -->\n"
-        #fi
-        page.refentry = page.func.name               # //refentry@id
-        page.refentry_title = page.func.name.strip() # //refentryinfo/title
-        page.refentrytitle = page.func.name          # //refmeta/refentrytitle
-        if page.includes:
-            page.funcsynopsisinfo += "\n"+page.includes
-        if not page.funcsynopsisinfo:
-            page.funcsynopsisinfo="\n"+' #include &lt;'+page.mainheader+'&gt;'
-        page.refpurpose = page.func.head
-        page.refname = page.func.name
-
-        def funcsynopsis_of(func):
-            return (
-                "\n <funcprototype>\n <funcdef>"+func.prespec+
-                " <function>"+func.name+"</function></funcdef>"+
-                "\n"+s(s(s(func.callspec,
-                           r"<parameters>\s*\(",r" "),
-                         r"\)\s*</parameters>",r" "),
-                       r"</paramdef>\s*,\s*",r"</paramdef>\n ")+
-                " </funcprototype>")
-        page.funcsynopsis = funcsynopsis_of(page.func)
-
-        page.description = (
-            html2docbook(this_function_link(page.func.body, page.func.name)))
-
-        if page.file_authors:
-            def add_authors(page, ename, email):
-                page.authors_list.append( ename+' '+email )
-                return ename+email
-            s(page.file_authors,
-              r"(?sx) \s* ([^<>]*) (<email>[^<>]*</email>) ", lambda x
-              : add_authors(page, x.group(1), x.group(2)))
-        #fi
-
-        if page.file_copyright:
-            page.copyright = "<screen>\n"+page.file_copyright+"</screen>\n"
-        #fi
-        return page
-    def __init__(page,func):
-        RefPage.__init__(page, func)
-        FunctionRefPage.reinit(page)
-    
-def refpage_list_from_function_list(funclist):
-    list = []
-    mapp = {}
-    for func in funclist:
-        mapp[func.name] = func
-    #od
-    for func in funclist:
-        page = FunctionRefPage(func)
-        if func.into and func.into not in mapp:
-            warn (# ............ (refpage_list_from_function_list) .......
-                "page '"+page.func.name+"' has no target => "+
-                "'"+page.func.into+"'"
-                "\n: going to reset .into of Function '"+page.func.name+"'")
-            func.into = None
-        #fi
-        list.append(FunctionRefPage(func))
-    return list
-#fu
-    
-# ordered list of pages
-refpage_list = refpage_list_from_function_list(function_list)
-
-class FunctionFamilyRefPage(RefPage):
-    def __init__(self, page):
-        RefPage.__init__(self, page.func)
-        self.seealso_list = [] # reset
-        self.refhint_list = []
-    def refhint_list_text(page):
-        T = ""
-        for hint in page.refhint_list:
-            T += hint
-        return T
-    def refentry_text(page):
-        return page.refhint_list_text() + "\n" + \
-               RefPage.refentry_text(page)
-    pass
-
-def docbook_pages_recombine(pagelist):
-    """ take a list of RefPages and create a new list where sections are
-        recombined in a way that their description is listed on the same
-        page and the manvol formatter creates symlinks to the combined
-        function description page - use the attribute 'into' to guide the
-        processing here as each of these will be removed from the output
-        list. If no into-pages are there then the returned list should
-        render to the very same output text like the input list would do """
-
-    list = []
-    combined = {}
-    for orig in pagelist:
-        if orig.func.into: continue
-        page = FunctionFamilyRefPage(orig)
-        combined[orig.func.name] = page ; list.append(page)
-
-        page.refentry = orig.refentry              # //refentry@id
-        page.refentry_title = orig.refentrytitle   # //refentryinfo/title
-        page.refentrytitle = orig.refentrytitle    # //refmeta/refentrytitle
-        page.includes = orig.includes
-        page.funcsynopsisinfo = orig.funcsynopsisinfo
-        page.refpurpose = orig.refpurpose
-        if orig.refhint:
-            page.refhint_list.append( orig.refhint )
-        if orig.refname:
-            page.refname_list.append( orig.refname )
-        elif orig.refname_list:
-            page.refname_list.extend( orig.refname_list )
-        if orig.funcsynopsis:
-            page.funcsynopsis_list.append( orig.funcsynopsis )
-        elif orig.refname_list:
-            page.funcsynopsis_list.extend( orig.funcsynopsis_list )
-        if orig.description:
-            page.description_list.append( orig.description )
-        elif orig.refname_list:
-            page.description_list.extend( orig.description_list )
-        if orig.seealso:
-            page.seealso_list.append( orig.seealso )
-        elif orig.seealso_list:
-            page.seealso_list.extend( orig.seealso_list )
-        if orig.authors:
-            page.authors_list.append( orig.authors )
-        elif orig.authors_list:
-            page.authors_list.extend( orig.authors_list )
-        if orig.copyright:
-            page.copyright_list.append( orig.copyright )
-        elif orig.refname_list:
-            page.copyright_list.extend( orig.copyright_list )
-    #od
-    for orig in pagelist:
-        if not orig.func.into: continue
-        if orig.func.into not in combined:
-            warn("page for '"+orig.func.name+
-                 "' has no target => '"+orig.func.into+"'")
-            page = FunctionFamilyRefPage(orig)
-        else:
-            page = combined[orig.func.into]
-
-        if orig.refname:
-            page.refname_list.append( orig.refname )
-        elif orig.refname_list:
-            page.refname_list.extend( orig.refname_list )
-        if orig.funcsynopsis:
-            page.funcsynopsis_list.append( orig.funcsynopsis )
-        elif orig.refname_list:
-            page.funcsynopsis_list.extend( orig.funcsynopsis_list )
-        if orig.description:
-            page.description_list.append( orig.description )
-        elif orig.refname_list:
-            page.description_list.extend( orig.description_list )
-        if orig.seealso:
-            page.seealso_list.append( orig.seealso )
-        elif orig.seealso_list:
-            page.seealso_list.extend( orig.seealso_list )
-        if orig.authors:
-            page.authors_list.append( orig.authors )
-        elif orig.authors_list:
-            page.authors_list.extend( orig.authors_list )
-        if orig.copyright:
-            page.copyright_list.append( orig.copyright )
-        elif orig.refname_list:
-            page.copyright_list.extend( orig.copyright_list )
-    #od
-    return list
-#fu
-
-combined_pages = docbook_pages_recombine(pagelist = refpage_list)
-
-# -----------------------------------------------------------------------
-
-class HeaderRefPage(RefPage):
-    pass
-
-def docbook_refpages_perheader(page_list): # headerlist
-    " creating the per-header manpage - a combination of function man pages "
-    header = {}
-    for page in page_list:
-        assert not page.func.into
-        file = page.func.src.file.mainheader # short for the mainheader index
-        if file not in header:
-            header[file] = HeaderRefPage(page.func)
-            header[file].id = s(file, r"[^\w\.]","-")
-            header[file].refentry = header[file].id
-            header[file].refentryinfo = None
-            header[file].refentry_date = page.refentry_date
-            header[file].refentry_productname = (
-                "the library "+page.refentry_productname)
-            header[file].manvolnum = page.manvolnum
-            header[file].refentrytitle = file
-            header[file].funcsynopsis = ""
-        if 1: # or += or if not header[file].refnamediv:
-            header[file].refpurpose = " library "
-            header[file].refname = header[file].id
-
-        if not header[file].funcsynopsisinfo and page.funcsynopsisinfo:
-            header[file].funcsynopsisinfo  = page.funcsynopsisinfo
-        if page.funcsynopsis:
-            header[file].funcsynopsis  += "\n"+page.funcsynopsis
-        if not header[file].copyright and page.copyright:
-            header[file].copyright = page.copyright
-        if not header[file].authors and page.authors:
-            header[file].authors = page.authors
-        if not header[file].authors and page.authors_list:
-            header[file].authors_list = page.authors_list
-        if not header[file].description:
-            found = m(commands.getoutput("cat "+o.package+".spec"),
-                      r"(?s)\%description\b([^\%]*)\%")
-            if found:
-                header[file].description = found.group(1)
-            elif not header[file].description:
-                header[file].description = "<para>" + (
-                    page.refentry_productname + " library") + "</para>";
-            #fi
-        #fi
-    #od
-    return header#list
-#fu
-
-def leaders(pagelist):
-    list = []
-    for page in pagelist:
-        if page.func.into : continue
-        list.append(page)
-    return list
-header_refpages = docbook_refpages_perheader(leaders(refpage_list))
-
-# -----------------------------------------------------------------------
-# printing the docbook file is a two-phase process - we spit out the
-# leader pages first - later we add more pages with _refstart pointing
-# to the leader page, so that xmlto will add the functions there. Only the
-# leader page contains some extra info needed for troff page processing.
-
-doctype = '<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"'
-doctype += "\n     "
-doctype += '"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">'+"\n"
-
-try:
-    F = open(o.docbookfile,"w")
-except IOError as error:
-    warn("can not open docbook output file: "+o.docbookfile, error)
-else:
-    print >> F, doctype, '<reference><title>Manual Pages</title>'
-
-    for page in combined_pages:
-        print >> F, page.refentry_text()
-    #od
-
-    for page in header_refpages.values():
-        if not page.refentry: continue
-        print >> F, "\n<!-- _______ "+page.id+" _______ -->",
-        print >> F, page.refentry_text()
-    #od
-
-    print >> F, "\n",'</reference>',"\n"
-    F.close()
-#fi
-
-# _____________________________________________________________________
-try:
-    F = open( o.dumpdocfile, "w")
-except IOError as error:
-    warn ("can not open"+o.dumpdocfile,error)
-else:
-    for func in function_list:
-        name = func.name
-        print >> F, "<fn id=\""+name+"\">"+"<!-- FOR \""+name+"\" -->\n"
-        for H in sorted_keys(func.dict()):
-            print >> F, "<"+H+" name=\""+name+"\">",
-            print >> F, str(func.dict()[H]),
-            print >> F, "</"+H+">"
-        #od
-        print >> F, "</fn><!-- END \""+name+"\" -->\n\n";
-    #od
-    F.close();
-#fi
-
-if errors: sys.exit(errors)
diff --git a/docs/makedocs.py b/docs/makedocs.py
index 244d069..7b30745 100644
--- a/docs/makedocs.py
+++ b/docs/makedocs.py
@@ -1,324 +1,307 @@
-from __future__ import print_function
-import sys
-from zzipdoc.match import *
-from zzipdoc.options import *
-from zzipdoc.textfile import *
-from zzipdoc.textfileheader import *
-from zzipdoc.functionheader import *
-from zzipdoc.functionprototype import *
-from zzipdoc.commentmarkup import *
-from zzipdoc.functionlisthtmlpage import *
-from zzipdoc.functionlistreference import *
-from zzipdoc.dbk2htm import *
-from zzipdoc.htmldocument import *
-from zzipdoc.docbookdocument import *
-
-def _src_to_xml(text):
-    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
-def _email_to_xml(text):
-    return text & Match("<([^<>]*@[^<>]*)>") >> "&lt;\\1&gt;"
-
-class PerFileEntry:
-    def __init__(self, header, comment):
-        self.textfileheader = header
-        self.filecomment = comment
-class PerFile:
+from __future__ import absolute_import, print_function
+
+import cgi
+import re
+from collections import OrderedDict
+from optparse import OptionParser
+
+from zzipdoc.commentmarkup import CommentMarkup
+from zzipdoc.dbk2htm import section2html, paramdef2html
+from zzipdoc.docbookdocument import DocbookDocument
+from zzipdoc.functionheader import FunctionHeaderList, FunctionHeader
+from zzipdoc.functionlisthtmlpage import FunctionListHtmlPage
+from zzipdoc.functionlistreference import FunctionListReference
+from zzipdoc.functionprototype import FunctionPrototype
+from zzipdoc.htmldocument import HtmlDocument
+from zzipdoc.textfile import TextFile
+from zzipdoc.textfileheader import TextFileHeader
+
+MYPY = False
+if MYPY:
+    from typing import List, Callable, TypeVar, Any, Optional
+    T = TypeVar('T')
+
+
+class PerFileEntry(object):
+    def __init__(self, textfileheader, filecomment):
+        self.textfileheader = textfileheader  # type: TextFileHeader
+        self.filecomment = filecomment  # type: CommentMarkup
+
+
+class PerFile(object):
     def __init__(self):
-        self.textfileheaders = []
-        self.filecomments = []
-        self.entries = []
+        self.entries = []  # type: List[PerFileEntry]
+
     def add(self, textfileheader, filecomment):
-        self.textfileheaders += [ textfileheader ]
-        self.filecomments += [ filecomment ]
-        self.entries += [ PerFileEntry(textfileheader, filecomment) ]
+        # type: (TextFileHeader, CommentMarkup) -> None
+        self.entries += [PerFileEntry(textfileheader, filecomment)]
+
     def where_filename(self, filename):
+        # type: (str) -> Optional[PerFileEntry]
         for entry in self.entries:
-            if entry.textfileheader.get_filename() == filename:
+            if entry.textfileheader.filename == filename:
                 return entry
         return None
-    def print_list_mainheader(self):
-        for t_fileheader in self.headers:
-            print (t_fileheader.get_filename(), t_fileheader.src_mainheader())
-        
-class PerFunctionEntry:
+
+
+class PerFunctionEntry(object):
     def __init__(self, header, comment, prototype):
-        self.header = header
-        self.comment = comment
-        self.prototype = prototype
-    def get_name(self):
-        return self.prototype.get_name()
-    def get_titleline(self):
-        return self.header.get_titleline()
-    def get_head(self):
-        return self.prototype
-    def get_body(self):
-        return self.comment
-class PerFunction:
-    def __init__(self):
-        self.headers = []
-        self.comments = []
-        self.prototypes = []
-        self.entries = []
-    def add(self, functionheader, functioncomment, functionprototype):
-        self.headers += [ functionheader ]
-        self.comments += [ functionprototype ]
-        self.prototypes += [ functionprototype ]
-        self.entries += [ PerFunctionEntry(functionheader, functioncomment,
-                                           functionprototype) ]
-    def print_list_titleline(self):
-        for funcheader in self.headers:
-            print (funcheader.get_filename(), "[=>]", funcheader.get_titleline())
-    def print_list_name(self):
-        for funcheader in self.prototypes:
-            print (funcheader.get_filename(), "[>>]", funcheader.get_name())
-
-class PerFunctionFamilyEntry:
+        self.header = header  # type: FunctionHeader
+        self.body = comment  # type: CommentMarkup
+        self.head = prototype  # type: FunctionPrototype
+
+    @property
+    def name(self):
+        return self.head.name
+
+    @property
+    def titleline(self):
+        return self.header.titleline
+
+
+class PerFunctionFamilyEntry(object):
     def __init__(self, leader):
-        self.leader = leader
-        self.functions = []
-    def contains(self, func):
-        for item in self.functions:
-            if item == func: return True
-        return False
+        self.functions = [leader]
+        self.name = leader.name
+
+    def __contains__(self, func):
+        return func in self.functions
+
     def add(self, func):
-        if not self.contains(func):
-            self.functions += [ func ]
-    def get_name(self):
-        if self.leader is None: return None
-        return self.leader.get_name()
-class PerFunctionFamily:
+        if func not in self:
+            self.functions.append(func)
+
+
+class PerFunctionFamily(object):
     def __init__(self):
-        self.functions = []
-        self.families = []
+        self.functions = OrderedDict()
         self.retarget = {}
-        self.entries = []
-    def add_PerFunction(self, per_list):
-        for item in per_list.entries:
-            add_PerFunctionEntry(item)
-    def add_PerFunctionEntry(self, item):
-        self.functions += [ item ]
-    def get_function(self, name):
-        for item in self.functions:
-            if item.get_name() == name:
-                return item
-        return None
+        self.entries = []  # type: List[PerFunctionFamilyEntry]
+
+    def add_function(self, item):
+        self.functions[item.name] = item
+
     def get_entry(self, name):
         for item in self.entries:
-            if item.get_name() == name:
+            if item.name == name:
                 return item
         return None
+
     def fill_families(self):
         name_list = {}
-        for func in self.functions:
-            name = func.get_name()
+        for func in self.functions.values():
+            name = func.name
             name_list[name] = func
-        for func in self.functions:
-            name = func.get_name()
-            line = func.get_titleline()
-            is_retarget = Match("=>\s*(\w+)")
-            if line & is_retarget:
-                into = is_retarget[1]
-                self.retarget[name] = is_retarget[1]
+
+        for func in self.functions.values():
+            name = func.name
+            line = func.titleline
+            is_retarget = re.search(r"=>\s*(\w+)", line)
+            if is_retarget:
+                into = is_retarget.group(1)
+                self.retarget[name] = into
+
         lead_list = []
-        for name in self.retarget:
-            into = self.retarget[name]
+
+        for name, into in self.retarget.items():
             if into not in name_list:
-                print ("function '"+name+"' retarget into '"+into+
-                       "' does not exist - keep alone")
+                print("function '" + name + "' retarget into '" + into +
+                      "' does not exist - keep alone")
             if into in self.retarget:
                 other = self.retarget[into]
-                print ("function '"+name+"' retarget into '"+into+
-                       "' which is itself a retarget into '"+other+"'")
+                print("function '" + name + "' retarget into '" + into +
+                      "' which is itself a retarget into '" + other + "'")
             if into not in lead_list:
-                lead_list += [ into ]
-        for func in self.functions:
-            name = func.get_name()
+                lead_list.append(into)
+
+        for name in self.functions:
             if name not in lead_list and name not in self.retarget:
-                lead_list += [ name ]
+                lead_list.append(name)
+
         for name in lead_list:
-            func = self.get_function(name)
-            if func is not None:
-                entry = PerFunctionFamilyEntry(func)
-                entry.add(func) # the first
-                self.entries += [ entry ]
-            else:
-                print ("head function '"+name+" has no entry")
-        for func in self.functions:
-            name = func.get_name()
+            func = self.functions.get(name)
+            if func is None:
+                print("head function '" + name + "' has no entry")
+                continue
+
+            entry = PerFunctionFamilyEntry(func)
+            entry.add(func)  # the first
+            self.entries.append(entry)
+
+        for name, func in self.functions.items():
             if name in self.retarget:
                 into = self.retarget[name]
                 entry = self.get_entry(into)
-                if entry is not None:
-                    entry.add(func) # will not add duplicates
-                else:
-                    print ("into function '"+name+" has no entry")
-    def print_list_name(self):
-        for family in self.entries:
-            name = family.get_name()
-            print (name, ":", end = " ")
-            for item in family.functions:
-                print (item.get_name(), ",", end = " ")
-            print ("")
-class HtmlManualPageAdapter:
-    def __init__(self, entry):
-        """ usually takes a PerFunctionEntry """
-        self.entry = entry
-    def get_name(self):
-        return self.entry.get_name()
-    def _head(self):
-        return self.entry.get_head()
-    def _body(self):
-        return self.entry.get_body()
-    def head_xml_text(self):
-        return self._head().xml_text()
-    def body_xml_text(self, name):
-        return self._body().xml_text(name)
-    def head_get_prespec(self):
-        return self._head().get_prespec()
-    def head_get_namespec(self):
-        return self._head().get_namespec()
-    def head_get_callspec(self):
-        return self._head().get_callspec()
-    def get_title(self):
-        return self._body().header.get_title()
-    def get_filename(self):
-        return self._body().header.get_filename()
-    def src_mainheader(self):
-        return self._body().header.parent.textfile.src_mainheader()
-    def get_mainheader(self):
-        return _src_to_xml(self.src_mainheader())
-class RefEntryManualPageAdapter:
-    def __init__(self, entry, per_file = None):
-        """ usually takes a PerFunctionEntry """
+                if entry is None:
+                    print("into function '" + name + "' has no entry")
+                    continue
+
+                entry.add(func)  # will not add duplicates
+
+
+class BaseManualPageAdapter(object):
+    def __init__(self, entry):  # type: (PerFunctionEntry) -> None
         self.entry = entry
-        self.per_file = per_file
-    def get_name(self):
-        return self.entry.get_name()
-    def _head(self):
-        return self.entry.get_head()
-    def _body(self):
-        return self.entry.get_body()
-    def _textfile(self):
-        return self._body().header.parent.textfile
-    def head_xml_text(self):
-        return self._head().xml_text()
-    def body_xml_text(self, name):
-        return self._body().xml_text(name)
-    def get_title(self):
-        return self._body().header.get_title()
-    def get_filename(self):
-        return self._body().header.get_filename()
+
+    @property
+    def name(self):
+        return self.entry.name
+
+    @property
+    def head(self):
+        return self.entry.head
+
+    @property
+    def body(self):
+        return self.entry.body
+
+    @property
     def src_mainheader(self):
-        return self._textfile().src_mainheader()
-    def get_mainheader(self):
-        return _src_to_xml(self.src_mainheader())
-    def get_includes(self):
+        return self.body.header.parent.textfile.mainheader
+
+    @property
+    def title(self):
+        return self.body.header.title
+
+    @property
+    def filename(self):
+        return self.body.header.filename
+
+    @property
+    def mainheader(self):
+        return cgi.escape(self.src_mainheader)
+
+
+class HtmlManualPageAdapter(BaseManualPageAdapter):
+    pass
+
+
+class RefEntryManualPageAdapter(BaseManualPageAdapter):
+    def __init__(self, entry, per_file):
+        # type: (PerFunctionEntry, PerFile) -> None
+        super(RefEntryManualPageAdapter, self).__init__(entry)
+        self.per_file = per_file  # type: PerFile
+
+    @property
+    def includes(self):
         return ""
+
+    @property
     def list_seealso(self):
-        return self._body().header.get_alsolist()
-    def get_authors(self):
-        comment = None
-        if self.per_file:
-            entry = self.per_file.where_filename(self.get_filename())
-            if entry:
-                comment = entry.filecomment.xml_text()
-        if comment:
-            check = Match(r"(?s)<para>\s*[Aa]uthors*\b:*"
-                          r"((?:.(?!</para>))*.)</para>")
-            if comment & check: return _email_to_xml(check[1])
-        return None
-    def get_copyright(self):
-        comment = None
-        if self.per_file:
-            entry = self.per_file.where_filename(self.get_filename())
-            if entry:
-                comment = entry.filecomment.xml_text()
-        if comment:
-            check = Match(r"(?s)<para>\s*[Cc]opyright\b"
-                          r"((?:.(?!</para>))*.)</para>")
-            if comment & check: return _email_to_xml(check[0])
+        return self.body.header.alsolist
+
+    @property
+    def comment(self):
+        if not self.per_file:
+            return ""
+
+        entry = self.per_file.where_filename(self.filename)
+        if not entry:
+            return ""
+
+        return entry.filecomment.xml_text()
+
+    def parse_email_para(self, name):
+        name = '[' + name[0].upper() + name[0].lower() + ']' + name[1:]
+        check = re.search(
+            r"(?s)<para>\s*" + name + r"\b((?:.(?!</para>))*.)</para>",
+            self.comment)
+        if check:
+            return re.sub("<([^<>]*@[^<>]*)>", r"&lt;\1&gt;", check.group(0))
         return None
 
-def makedocs(filenames, o):
-    textfiles = []
-    for filename in filenames:
-        textfile = TextFile(filename)
-        textfile.parse()
-        textfiles += [ textfile ]
+    @property
+    def authors(self):
+        return self.parse_email_para('authors')
+
+    @property
+    def copyright(self):
+        return self.parse_email_para('copyright')
+
+
+def makedocs(filenames, o):  # type: (List[str], Any) -> None
+    textfiles = [TextFile(filename) for filename in filenames]
+
     per_file = PerFile()
     for textfile in textfiles:
         textfileheader = TextFileHeader(textfile)
-        textfileheader.parse()
-        filecomment = CommentMarkup(textfileheader)
-        filecomment.parse()
-        per_file.add(textfileheader, filecomment)
-    funcheaders = []
-    for textfile in per_file.textfileheaders:
-        funcheader = FunctionHeaderList(textfile)
-        funcheader.parse()
-        funcheaders += [ funcheader ]
-    per_function = PerFunction()
-    for funcheader in funcheaders:
-        for child in funcheader.get_children():
-            funcprototype = FunctionPrototype(child)
-            funcprototype.parse()
-            funccomment = CommentMarkup(child)
-            funccomment.parse()
-            per_function.add(child, funccomment, funcprototype)
+        per_file.add(textfileheader, CommentMarkup(textfileheader))
+
+    funcheaders = [FunctionHeaderList(e.textfileheader)
+                   for e in per_file.entries]
     per_family = PerFunctionFamily()
-    for item in per_function.entries:
-        per_family.add_PerFunctionEntry(item)
+    for funcheader in funcheaders:
+        for child in funcheader.children:
+            entry = PerFunctionEntry(child, CommentMarkup(child),
+                                     FunctionPrototype(child))
+            per_family.add_function(entry)
     per_family.fill_families()
-    # debug output....
-    # per_file.print_list_mainheader()
-    # per_function.print_list_titleline()
-    # per_function.print_list_name()
-    # per_family.print_list_name()
-    #
-    html = FunctionListHtmlPage(o)
-    for item in per_family.entries:
-        for func in item.functions:
-            func_adapter = HtmlManualPageAdapter(func)
-            if o.onlymainheader and not (Match("<"+o.onlymainheader+">")
-                                         & func_adapter.src_mainheader()):
-                    continue
-            html.add(func_adapter)
-        html.cut()
-    html.cut()
-    class _Html_:
-        def __init__(self, html):
-            self.html = html
-        def html_text(self):
-            return section2html(paramdef2html(self.html.xml_text()))
-        def get_title(self):
-            return self.html.get_title()
-    HtmlDocument(o).add(_Html_(html)).save(o.output+o.suffix)
-    #
-    man3 = FunctionListReference(o)
+
+    out_filename = o.output + o.suffix
+
+    html = make_page_from_functions(
+        o.onlymainheader, per_family,
+        page=FunctionListHtmlPage(o.package, o.version, o.onlymainheader),
+        make_adapter=HtmlManualPageAdapter)
+
+    doc = HtmlDocument(o.version) \
+        .set_title(html.title) \
+        .add(section2html(paramdef2html(html.make_xml_text())))
+    _save_doc(doc, out_filename + "." + o.html)
+
+    man3 = make_page_from_functions(
+        o.onlymainheader, per_family,
+        page=FunctionListReference(o.version, o.package),
+        make_adapter=lambda f: RefEntryManualPageAdapter(f, per_file))
+    doc = DocbookDocument() \
+        .set_title(man3.title) \
+        .add(man3)
+    _save_doc(doc, out_filename + "." + o.docbook)
+
+
+def _save_doc(doc, filename):
+    try:
+        print("Writing {filename}".format(filename=filename))
+        with open(filename, "w") as f:
+            doc.save(f)
+    except IOError:
+        print("Error saving document to {filename}".format(filename=filename))
+
+
+def make_page_from_functions(onlymainheader, per_family, page, make_adapter):
+    # type: (str, PerFunctionFamily, T, Callable[[PerFunctionEntry], BaseManualPageAdapter]) -> T
     for item in per_family.entries:
         for func in item.functions:
-            func_adapter = RefEntryManualPageAdapter(func, per_file)
-            if o.onlymainheader and not (Match("<"+o.onlymainheader+">")
-                                         & func_adapter.src_mainheader()):
+            func_adapter = make_adapter(func)
+            if onlymainheader:
+                if not re.search("<" + onlymainheader + ">",
+                                 func_adapter.src_mainheader):
                     continue
-            man3.add(func_adapter)
-        man3.cut()
-    man3.cut()
-    DocbookDocument(o).add(man3).save(o.output+o.suffix)
-    
-        
+            page.add(func_adapter)
+        page.cut()
+    page.cut()
+    return page
+
+
+def main():
+    parser = OptionParser()
+    parser.add_option("--package", default="ZZipLib", metavar="NAME",
+                      help="Name of software being documented")
+    parser.add_option("--html", default="html", metavar="SUFFIX",
+                      help="Extension for generated HTML files")
+    parser.add_option("--docbook", default="docbook", metavar="SUFFIX",
+                      help="Extension for generated docbook files")
+    parser.add_option("--output", default="zziplib", metavar="FILENAME",
+                      help="Help filename base")
+    parser.add_option("--suffix", default="", help="Help filename suffix")
+    parser.add_option("--version", default="", metavar="VERSION",
+                      help="Current version of software being documented")
+    parser.add_option("--onlymainheader", default="", metavar="FILENAME",
+                      help="Specific header to focus on")
+    opts, args = parser.parse_args()
+
+    makedocs(args, opts)
+
+
 if __name__ == "__main__":
-    filenames = []
-    o = Options()
-    o.package = "ZZipLib"
-    o.program = sys.argv[0]
-    o.html = "html"
-    o.docbook = "docbook"
-    o.output = "zziplib"
-    o.suffix = ""
-    for item in sys.argv[1:]:
-        if o.scan(item): continue
-        filenames += [ item ]
-    makedocs(filenames, o)
-    
-        
+    main()
diff --git a/docs/zzipdoc/commentmarkup.py b/docs/zzipdoc/commentmarkup.py
index 02a235e..c01c552 100644
--- a/docs/zzipdoc/commentmarkup.py
+++ b/docs/zzipdoc/commentmarkup.py
@@ -1,85 +1,92 @@
-from .match import Match
+import re
 
-def markup_link_syntax(text):
+
+def _markup_link_syntax(text):
     """ markup the link-syntax ` => somewhere ` in the text block """
-    return (text
-            & Match(r"(?m)(^|\s)\=\>\"([^\"]*)\"")
-            >> r"\1<link>\2</link>"
-            & Match(r"(?m)(^|\s)\=\>\'([^\']*)\'")
-            >> r"\1<link>\2</link>"
-            & Match(r"(?m)(^|\s)\=\>\s(\w[\w.]*\w\(\d+\))")
-            >> r"\1<link>\2</link>"
-            & Match(r"(?m)(^|\s)\=\>\s([^\s\,\.\!\?]+)")
-            >> r"\1<link>\2</link>")
+    text = re.sub(r"(^|\s)=>\"([^\"]*)\"", r"\1<link>\2</link>", text,
+                  flags=re.M)
+    text = re.sub(r"(^|\s)=>\'([^\']*)\'", r"\1<link>\2</link>", text,
+                  flags=re.M)
+    text = re.sub(r"(^|\s)=>\s(\w[\w.]*\w\(\d+\))", r"\1<link>\2</link>", text,
+                  flags=re.M)
+    text = re.sub(r"(^|\s)=>\s([^\s,.!?]+)", r"\1<link>\2</link>", text,
+                  flags=re.M)
+    return text
+
+
+def _markup_line(line):
+    return (line
+            .replace("<c>", "<code>")
+            .replace("</c>", "</code>"))
+
+
+def _markup_para_line(line):
+    return _markup_link_syntax(_markup_line(line))
+
+
+def _markup_screen_line(line):
+    return _markup_line(line.replace("&", "&amp;")
+                        .replace("<", "&lt;")
+                        .replace(">", "&gt;"))
+
 
-class CommentMarkup:
+class CommentMarkup(object):
     """ using a structure having a '.comment' item - it does pick it up
     and enhances its text with new markups so that they can be represented
     in xml. Use self.xml_text() to get markup text (knows 'this function') """
-    def __init__(self, header = None):
+
+    def __init__(self, header):
         self.header = header
-        self.text = None     # xml'text
-    def get_filename(self):
-        if self.header is None:
-            return None
-        return self.header.get_filename()
-    def parse(self, header = None):
-        if header is not None:
-            self.header = header
-        if self.header is None:
-            return False
-        comment = self.header.comment
-        try:
-            comment = self.header.get_otherlines()
-        except Exception as e:
-            pass
+        self.filename = header.filename
+
+        if hasattr(header, 'otherlines'):
+            comment = header.otherlines
+        else:
+            comment = header.comment
+
         mode = ""
         text = ""
         for line in comment.split("\n"):
-            check = Match()
-            if line & check(r"^\s?\s?\s?[*]\s+[*]\s(.*)"):
+            check = re.search(r"^\s?\s?\s?[*]\s+[*]\s(.*)", line)
+            if check:
                 if mode != "ul":
-                    if mode: text += "</"+mode+">"
-                    mode = "ul" ; text += "<"+mode+">"
-                line = check.group(1)
-                text += "<li><p> "+self.markup_para_line(line)+" </p></li>\n"
-            elif line & check(r"^\s?\s?\s?[*](.*)"):
-                if mode != "para":
-                    if mode: text += "</"+mode+">"
-                    mode = "para" ; text += "<"+mode+">"
+                    if mode: text += "</" + mode + ">"
+                    mode = "ul"
+                    text += "<" + mode + ">"
                 line = check.group(1)
-                if line.strip() == "":
-                    text += "</para><para>"+"\n"
-                else:
-                    text += " "+self.markup_para_line(line)+"\n"
+                text += "<li><p> " + _markup_para_line(line) + " </p></li>\n"
             else:
-                if mode != "screen":
-                    if mode: text += "</"+mode+">"
-                    mode = "screen" ; text += "<"+mode+">"
-                text += " "+self.markup_screen_line(line)+"\n"
-        if mode: text += "</"+mode+">"+"\n"
-        self.text = (text
-                     & Match(r"(<para>)(\s*[R]eturns)") >>r"\1This function\2"
-                     & Match(r"(?s)<para>\s*</para><para>") >> "<para>"
-                     & Match(r"(?s)<screen>\s*</screen>") >> "")
-        return True
-    def markup_screen_line(self, line):
-        return self.markup_line(line.replace("&","&amp;")
-                                .replace("<","&lt;")
-                                .replace(">","&gt;"))
-    def markup_para_line(self, line):
-        return markup_link_syntax(self.markup_line(line))
-    def markup_line(self, line):
-        return (line
-                .replace("<c>","<code>")
-                .replace("</c>","</code>"))
-    def xml_text(self, functionname = None):
-        if self.text is None:
-            if not self.parse(): return None
+                check = re.search(r"^\s?\s?\s?[*](.*)", line)
+                if check:
+                    if mode != "para":
+                        if mode: text += "</" + mode + ">"
+                        mode = "para";
+                        text += "<" + mode + ">"
+                    line = check.group(1)
+                    if line.strip() == "":
+                        text += "</para><para>" + "\n"
+                    else:
+                        text += " " + _markup_para_line(line) + "\n"
+                else:
+                    if mode != "screen":
+                        if mode: text += "</" + mode + ">"
+                        mode = "screen"
+                        text += "<" + mode + ">"
+                    text += " " + _markup_screen_line(line) + "\n"
+        if mode:
+            text += "</" + mode + ">" + "\n"
+        text = re.sub(r"(<para>)(\s*[R]eturns)", r"\1This function\2", text)
+        text = re.sub(r"<para>\s*</para><para>", "<para>", text, flags=re.S)
+        text = re.sub(r"<screen>\s*</screen>", "", text, flags=re.S)
+        self.text = text
+
+    def xml_text(self, functionname=None):
         text = self.text
         if functionname is not None:
-            def function(text): return "<function>"+text+"</function> function"
+            def function(name):
+                return "<function>" + name + "</function> function"
+
             text = (text
-                    .replace("this function", "the "+function(functionname))
-                    .replace("This function", "The "+function(functionname)))
+                    .replace("this function", "the " + function(functionname))
+                    .replace("This function", "The " + function(functionname)))
         return text
diff --git a/docs/zzipdoc/dbk2htm.py b/docs/zzipdoc/dbk2htm.py
index 9296ab8..97d1969 100644
--- a/docs/zzipdoc/dbk2htm.py
+++ b/docs/zzipdoc/dbk2htm.py
@@ -1,26 +1,25 @@
-from .match import Match
-import string
+import re
+
+_mapping = {
+    "<screen>": "<pre>",
+    "</screen>": "</pre>",
+    "<para>": "<p>",
+    "</para>": "</p>" ,
+    "<function>": "<link>",
+    "</function>": "</link>",
+}
 
-class dbk2htm_conversion:
-    mapping = { "<screen>" : "<pre>", "</screen>" : "</pre>",
-                "<para>" : "<p>", "</para>" : "</p>" ,
-                "<function>" : "<link>", "</function>" : "</link>" }
-    def __init__(self):
-        pass
-    def section2html(self, text):
-        for find, replace in self.mapping.items():
-            text = text.replace(find, replace)
-        return text
-    def paramdef2html(self, text):
-        s = Match()
-        txt = text & s(r"\s+<paramdef>") >> r"\n<nobr>"
-        txt &= s(r"<paramdef>") >> r"<nobr>"
-        txt &= s(r"</paramdef>") >> r"</nobr>"
-        txt &= s(r"<parameters>") >> r"\n <code>"
-        txt &= s(r"</parameters>") >> r"</code>\n"
-        return txt
 
 def section2html(text):
-    return dbk2htm_conversion().section2html(text)
+    for find, replace in _mapping.items():
+        text = text.replace(find, replace)
+    return text
+
+
 def paramdef2html(text):
-    return dbk2htm_conversion().paramdef2html(text)
+    text = re.sub(r"\s+<paramdef>", r"\n<nobr>", text)
+    text = text.replace("<paramdef>", "<nobr>")
+    text = text.replace("</paramdef>", "</nobr>")
+    text = text.replace("<parameters>", "\n <code>")
+    text = text.replace("</parameters>", "</code>\n")
+    return text
diff --git a/docs/zzipdoc/docbookdocument.py b/docs/zzipdoc/docbookdocument.py
index 8656a69..163e3e2 100644
--- a/docs/zzipdoc/docbookdocument.py
+++ b/docs/zzipdoc/docbookdocument.py
@@ -1,96 +1,73 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
 from __future__ import print_function
-from .match import Match
+import re
 
-class DocbookDocument:
+from zzipdoc.document import BaseDocument
+
+
+class DocbookDocument(BaseDocument):
     """ binds some xml content page with additional markup - in this
     variant we set the rootnode container to 'reference' and the DTD
     to the Docbook 4.1.2 version. Modify as you like."""
-    has_title_child = [ "book", "chapter", "section", "reference" ]
+    has_title_child = ["book", "chapter", "section", "reference"]
     docbook_dtd = (
-        ' PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"'+"\n"+
-        '       "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"')
-    def __init__(self, o, filename = None):
-        self.o = o
+            ' PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"' + "\n" +
+            '       "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"')
+
+    def __init__(self):
+        super(DocbookDocument, self).__init__()
         self.rootnode = "reference"
-        self.filename = filename
-        self.title = ""
-        self.text = []
-    def add(self, text):
-        """ add some content """
-        self.text += [ text ]
-        return self
-    def get_title(self):
-        if self.title: return title
-        try:   return self.text[0].get_title()
-        except Exception as e: pass
-        return self.title
+
     def _xml_doctype(self, rootnode):
-        return "<!DOCTYPE "+rootnode+self.docbook_dtd+">"
+        return "<!DOCTYPE " + rootnode + self.docbook_dtd + ">"
+
     def _xml_text(self, xml):
         """ accepts adapter objects with .xml_text() """
-        try:   return xml.xml_text()
-        except Exception as e: print("DocbookDocument/text", e); pass
+        try:
+            return xml.xml_text()
+        except Exception as e:
+            print("DocbookDocument/text", e)
         return str(xml)
+
     def _fetch_rootnode(self, text):
-        fetch = Match(r"^[^<>]*<(\w+)\b")
-        if text & fetch: return fetch[1]
+        fetch = re.search(r"^[^<>]*<(\w+)\b", text)
+        if fetch:
+            return fetch.group(1)
         return self.rootnode
-    def _filename(self, filename):
-        if filename is not None:
-            self.filename = filename
-        filename = self.filename
-        if not filename & Match(r"\.\w+$"):
-            ext = self.o.docbook
-            if not ext: ext = "docbook"
-            filename += "."+ext
-        return filename
-    def save(self, filename = None):
-        filename = self._filename(filename)
-        print("writing '"+filename+"'")
+
+    def save(self, fd):
         if len(self.text) > 1:
-            self.save_all(filename)
+            self.save_all(fd)
         else:
-            self.save_text(filename, self.text[0])
-    def save_text(self, filename, text):
-        try:
-            fd = open(filename, "w")
-            xml_text = self._xml_text(text)
-            rootnode = self._fetch_rootnode(xml_text)
-            doctype = self._xml_doctype(rootnode)
-            print(doctype, file=fd)
-            print(xml_text, file=fd)
-            fd.close()
-            return True
-        except IOError as e:
-            print("could not open '"+filename+"'file", e)
-            return False
-    def save_all(self, filename):
+            self.save_text(fd, self.text[0])
+
+    def save_text(self, fd, text):
+        xml_text = self._xml_text(text)
+        rootnode = self._fetch_rootnode(xml_text)
+        doctype = self._xml_doctype(rootnode)
+        print(doctype, file=fd)
+        print(xml_text, file=fd)
+
+    def save_all(self, fd):
         assert len(self.text) > 1
-        try:
-            fd = open(filename, "w")
-            xml_text = self._xml_text(self.text[0])
-            rootnode = self._fetch_rootnode(xml_text)
-            if rootnode == self.rootnode:
-                rootnode = "book"
-            else:
-                rootnode = self.rootnode
-            doctype = self._xml_doctype(rootnode)
-            print(doctype, file=fd)
-            title = self.get_title()
-            if title and self.rootnode in self.has_title_child:
-                print("<"+self.rootnode+'><title>'+title+'</title>', file=fd)
-            elif title:
-                print("<"+self.rootnode+' id="'+title+'">', file=fd)
-            else:
-                print("<"+self.rootnode+'>', file=fd)
-            for text in self.text:
-                text = self._xml_text(text)
-                print(text, file=fd)
-            print("</"+self.rootnode+">", file=fd)
-            fd.close()
-            return True
-        except IOError as e:
-            print("could not open '"+filename+"' file", e)
-            return False
+        xml_text = self._xml_text(self.text[0])
+        rootnode = self._fetch_rootnode(xml_text)
+        if rootnode == self.rootnode:
+            rootnode = "book"
+        else:
+            rootnode = self.rootnode
+        doctype = self._xml_doctype(rootnode)
+        print(doctype, file=fd)
+        title = self.title
+        if title and self.rootnode in self.has_title_child:
+            print("<" + self.rootnode + '><title>' + title + '</title>',
+                  file=fd)
+        elif title:
+            print("<" + self.rootnode + ' id="' + title + '">', file=fd)
+        else:
+            print("<" + self.rootnode + '>', file=fd)
+        for text in self.text:
+            text = self._xml_text(text)
+            print(text, file=fd)
+        print("</" + self.rootnode + ">", file=fd)
diff --git a/docs/zzipdoc/document.py b/docs/zzipdoc/document.py
new file mode 100644
index 0000000..8fb4176
--- /dev/null
+++ b/docs/zzipdoc/document.py
@@ -0,0 +1,12 @@
+class BaseDocument(object):
+    def __init__(self):
+        self.text = []
+        self.title = ""
+
+    def add(self, text):
+        self.text.append(text)
+        return self
+
+    def set_title(self, title):
+        self.title = title
+        return self
diff --git a/docs/zzipdoc/functionheader.py b/docs/zzipdoc/functionheader.py
index cc4235f..38dc507 100644
--- a/docs/zzipdoc/functionheader.py
+++ b/docs/zzipdoc/functionheader.py
@@ -1,21 +1,21 @@
-from .match import Match
+import re
 
-class FunctionHeader:
+
+class FunctionHeader(object):
     """ parsing the comment block that is usually presented before
     a function prototype - the prototype part is passed along
     for further parsing through => FunctionPrototype """
+
     def __init__(self, functionheaderlist, comment, prototype):
-        self.parent = functionheaderlist
-        self.comment = comment
-        self.prototype = prototype
+        self.parent = functionheaderlist  # type: FunctionHeaderList
+        self.filename = self.parent.filename
+        self.comment = comment  # type: str
+        self.prototype = prototype  # type: str
         self.firstline = None
         self.otherlines = None
         self.titleline = None
         self.alsolist = []
-    def get_filename(self):
-        return self.parent.get_filename()
-    def parse_firstline(self):
-        if not self.comment: return False
+
         x = self.comment.find("\n")
         if x > 0:
             self.firstline = self.comment[:x]
@@ -26,71 +26,37 @@ def parse_firstline(self):
         else:
             self.firstline = self.comment
             self.otherlines = ""
-        return True
-    def get_firstline(self):
-        if self.firstline is None:
-            if not self.parse_firstline(): return ""
-        return self.firstline
-    def get_otherlines(self):
-        if self.firstline is None:
-            if not self.parse_firstline(): return ""
-        return self.otherlines
-    def parse_titleline(self):
-        """ split extra-notes from the firstline - keep only titleline """
-        line = self.get_firstline()
-        if line is None: return False
+
+        line = self.firstline
         self.titleline = line
         self.alsolist = []
         x = line.find("also:")
         if x > 0:
-            self.titleline = line[:x]
-            for also in line[x+5:].split(","):
-                self.alsolist += [ also.strip() ]
-        self._alsolist = self.alsolist
-        return True
-    def get_alsolist(self):
-        """ gets the see-also notes from the firstline """
-        if self.titleline is None:
-            if not self.parse_titleline(): return None
-        return self.alsolist
-    def get_titleline(self):
-        """ gets firstline with see-also notes removed """
-        if self.titleline is None:
-            if not self.parse_titleline(): return False
-        return self.titleline
-    def get_title(self):
+            self._titleline = line[:x]
+            for also in line[x + 5:].split(","):
+                self.alsolist += [also.strip()]
+        self.alsolist = self.alsolist
+
+    @property
+    def title(self):
         """ gets titleline unless that is a redirect """
-        titleline = self.get_titleline()
-        if titleline & Match(r"^\s*=>"): return ""
-        if titleline & Match(r"^\s*<link>"): return ""
+        titleline = self.titleline
+        if titleline.strip().startswith("=>"): return ""
+        if titleline.strip().startswith("<link>"): return ""
         return titleline
-    def get_prototype(self):
-        return self.prototype
-    
-class FunctionHeaderList:
+
+
+class FunctionHeaderList(object):
     """ scan for comment blocks in the source file that are followed by
     something quite like a C definition (probably a function definition).
     Unpack the occurrences and fill self.comment and self.prototype. """
-    def __init__(self, textfile = None):
-        self.textfile = textfile # TextFile
-        self.children = None     # src'style
-    def parse(self, textfile = None):
-        if textfile is not None:
-            self.textfile = textfile
-        if self.textfile is None:
-            return False
-        text = self.textfile.get_src_text()
-        m = Match(r"(?s)\/\*[*]+(?=\s)"
-                  r"((?:.(?!\*\/))*.)\*\/"
-                  r"([^/\{\}\;\#]+)[\{\;]")
-        self.children = []
-        for found in m.finditer(text):
-            child = FunctionHeader(self, found.group(1), found.group(2))
-            self.children += [ child ]
-        return len(self.children) > 0
-    def get_filename(self):
-        return self.textfile.get_filename()
-    def get_children(self):
-        if self.children is None:
-            if not self.parse(): return []
-        return self.children
+
+    def __init__(self, textfile=None):
+        self.textfile = textfile
+        self.filename = textfile.filename
+
+        text = textfile.src_text
+        m = re.compile(
+            r"(?s)/\*[*]+(?=\s)((?:.(?!\*/))*.)\*/([^/{};#]+)[{;]")
+        self.children = [FunctionHeader(self, comment, prototype)
+                         for comment, prototype in m.findall(text)]
diff --git a/docs/zzipdoc/functionlisthtmlpage.py b/docs/zzipdoc/functionlisthtmlpage.py
index 7f8d2e0..23629f4 100644
--- a/docs/zzipdoc/functionlisthtmlpage.py
+++ b/docs/zzipdoc/functionlisthtmlpage.py
@@ -1,15 +1,22 @@
 from __future__ import print_function
-from .options import *
-from .match import Match
 
-class FunctionListHtmlPage:
+import re
+
+
+def _sane(text):
+    return (text
+            .replace("<function>", "<code>")
+            .replace("</function>", "</code>"))
+
+
+class FunctionListHtmlPage(object):
     """ The main part here is to create a TOC (table of contents) at the
     start of the page - linking down to the descriptions of the functions.
     Sure we need to generate anchors on the fly. Additionally, all the
     non-html (docbook-like) markup needs to be converted for ouput. -
-    each element to be added should implement get_name(), get_head() and
-    get_body() with the latter two having a xml_text() method."""
-    _null_table100 =  '<table border="0" width="100%"' \
+    each element to be added should have the properties name, head and
+    body with the latter two having a xml_text() method."""
+    _null_table100 = '<table border="0" width="100%"' \
                      ' cellpadding="0" cellspacing="0">'
     _ul_start = '<table width="100%">'
     _ul_end = '</table>'
@@ -17,112 +24,127 @@ class FunctionListHtmlPage:
     _li_end = '</td></tr>'
     http_opengroup = "http://www.opengroup.org/onlinepubs/000095399/functions/"
     http_zlib = "http://www.zlib.net/manual.html"
-    def __init__(self, o = None):
+
+    def __init__(self, package, version, onlymainheader):
+        self.package = package
+        self.version = version
+        self.onlymainheader = onlymainheader
         self.toc = ""
         self.text = ""
         self.head = ""
         self.body = ""
         self.anchors = []
-        self.o = o
-        if self.o is None: self.o = Options()
         self.not_found_in_anchors = []
+
     def cut(self):
-        self.text += ("<dt>"+self._ul_start+self.head+self._ul_end+"</dt>"+
-                      "<dd>"+self._ul_start+self.body+self._ul_end+"</dd>")
+        self.text += (
+            "<dt>" + self._ul_start + self.head + self._ul_end + "</dt>" +
+            "<dd>" + self._ul_start + self.body + self._ul_end + "</dd>")
         self.head = ""
         self.body = ""
+
     def add(self, entry):
-        name = entry.get_name()
-        head_text = entry.head_xml_text()
-        body_text = entry.body_xml_text(name)
+        name = entry.name
+        head_text = str(entry.head)
+        body_text = entry.body.xml_text(name)
         if not head_text:
             print("no head_text for", name)
             return
-        try:
-            prespec = entry.head_get_prespec()
-            namespec = entry.head_get_namespec()
-            callspec = entry.head_get_callspec()
-            head_text = ("<code><b><function>"+namespec+"</function></b>"
-                         +callspec+" : "+prespec+"</code>")
-        except Exception as e:
-            pass
-        try:
-            extraline = ""
-            title = entry.get_title()
-            filename = entry.get_filename().replace("../","")
-            if title:
-                subtitle = '&nbsp;<em>'+title+'</em>'
-                extraline = (self._null_table100+'<td> '+subtitle+' </td>'+
-                             '<td align="right"> '+
-                             '<em><small>'+filename+'</small></em>'+
-                             '</td></table>')
-            body_text = extraline + body_text
-        except Exception as e:
-            pass
+
+        prespec = entry.head.prespec
+        namespec = entry.head.namespec
+        callspec = entry.head.callspec
+        head_text = ("<code><b><function>" + namespec + "</function></b>"
+                     + callspec + " : " + prespec + "</code>")
+
+        extraline = ""
+        title = entry.title
+        filename = entry.filename.replace("../", "")
+        if title:
+            subtitle = '&nbsp;<em>' + title + '</em>'
+            extraline = (
+                        self._null_table100 + '<td> ' + subtitle + ' </td>' +
+                        '<td align="right"> ' +
+                        '<em><small>' + filename + '</small></em>' +
+                        '</td></table>')
+        body_text = extraline + body_text
+
+        function_tag = re.compile(r"<function>(\w*)</function>")
+
         def link(text):
-            return (text & Match("<function>(\w*)</function>")
-                    >> "<link>\\1</link>")
+            return function_tag.sub(r"<link>\1</link>", text)
+
         def here(text):
-            has_function = Match("<function>(\w*)</function>")
-            if text & has_function:
-                func = has_function[1]
-                self.anchors += [ func ]
-                return (text & has_function
-                        >> '<a name="'+"\\1"+'">'+"\\1"+'</a>')
+            has_function = function_tag.search(text)
+            if has_function:
+                self.anchors.append(has_function.group(1))
+                return function_tag.sub(r'<a name="\1">\1</a>', text)
             else:
                 return text
-        self.toc += self._li_start+self.sane(link(head_text))+self._li_end
-        self.head += self._li_start+self.sane(here(head_text))+self._li_end
-        self.body += self._li_start+self.sane(body_text)+self._li_end
-    def get_title(self):
-        return self.o.package+" Library Functions"
-    def xml_text(self):
+
+        self.toc += self._li_start + _sane(link(head_text)) + self._li_end
+        self.head += self._li_start + _sane(here(head_text)) + self._li_end
+        self.body += self._li_start + _sane(body_text) + self._li_end
+
+    @property
+    def title(self):
+        return self.package + " Library Functions"
+
+    def make_xml_text(self):
         self.cut()
-        return ("<h2>"+self.get_title()+"</h2>"+
-                self.version_line()+
-                self.mainheader_line()+
-                self._ul_start+
-                self.resolve_links(self.toc)+
-                self._ul_end+
-                "<h3>Documentation</h3>"+
-                "<dl>"+
-                self.resolve_links(self.text)+
+        return ("<h2>" + self.title + "</h2>" +
+                self.version_line +
+                self.mainheader_line +
+                self._ul_start +
+                self.resolve_links(self.toc) +
+                self._ul_end +
+                "<h3>Documentation</h3>" +
+                "<dl>" +
+                self.resolve_links(self.text) +
                 "</dl>")
+
+    @property
     def version_line(self):
-        if self.o.version:
-            return "<p>Version "+self.o.version+"</p>"
+        if self.version:
+            return "<p>Version " + self.version + "</p>"
         return ""
+
+    @property
     def mainheader_line(self):
-        if self.o.onlymainheader:
-            include = "#include &lt;"+self.o.onlymainheader+"&gt;"
-            return "<p><big><b><code>"+include+"</code></b></big></p>"
+        if self.onlymainheader:
+            include = "#include &lt;" + self.onlymainheader + "&gt;"
+            return "<p><big><b><code>" + include + "</code></b></big></p>"
         return ""
+
     def resolve_links(self, text):
-        text &= (Match("(?s)<link>([^<>]*)(\(\d\))</link>")
-                 >> (lambda x: self.resolve_external(x.group(1), x.group(2))))
-        text &= (Match("(?s)<link>(\w+)</link>")
-                 >> (lambda x: self.resolve_internal(x.group(1))))
+        text = re.sub(r"(?s)<link>([^<>]*)(\(\d\))</link>",
+                      (lambda x: self.resolve_external(x.group(1), x.group(2))),
+                      text)
+        text = re.sub(r"(?s)<link>(\w+)</link>",
+                      (lambda x: self.resolve_internal(x.group(1))), text)
+        text = re.sub(r"(?s)<link>([^<>]*)</link>", r"<code>\1</code>", text)
+
+        # Note: not_found_in_anchors mutated by resolve_internal, do not reorder
         if len(self.not_found_in_anchors):
             print("not found in anchors:", self.not_found_in_anchors)
-        return (text & Match("(?s)<link>([^<>]*)</link>")
-                >> "<code>\\1</code>")
+
+        return text
+
     def resolve_external(self, func, sect):
-        x = Match()
-        if func & x("^zlib(.*)"):
-            return ('<a href="'+self.http_zlib+x[1]+'">'+
-                    "<code>"+func+sect+"</code>"+'</a>')
-        if sect & x("[23]"):
-            return ('<a href="'+self.http_opengroup+func+'.html">'+
-                     "<code>"+func+sect+"</code>"+'</a>')
-        return "<code>"+func+"<em>"+sect+"</em></sect>"
+        zlib_found = re.search("^zlib(.*)", func)
+        if zlib_found:
+            return ('<a href="' + self.http_zlib + zlib_found.group(1) + '">' +
+                    "<code>" + func + sect + "</code>" + '</a>')
+
+        manpage_found = re.search("[23]", sect)
+        if manpage_found:
+            return ('<a href="' + self.http_opengroup + func + '.html">' +
+                    "<code>" + func + sect + "</code>" + '</a>')
+        return "<code>" + func + "<em>" + sect + "</em></sect>"
+
     def resolve_internal(self, func):
         if func in self.anchors:
-            return '<code><a href="#'+func+'">'+func+"</a></code>"
+            return '<code><a href="#{func}">{func}</a></code>'.format(func=func)
         if func not in self.not_found_in_anchors:
-            self.not_found_in_anchors += [ func ]
-        return "<code><u>"+func+"</u></code>"
-    def sane(self, text):
-        return (text 
-                .replace("<function>", "<code>")
-                .replace("</function>", "</code>"))
-                
+            self.not_found_in_anchors.append(func)
+        return "<code><u>{func}</u></code>".format(func=func)
diff --git a/docs/zzipdoc/functionlistreference.py b/docs/zzipdoc/functionlistreference.py
index afbf1cf..ed58a46 100644
--- a/docs/zzipdoc/functionlistreference.py
+++ b/docs/zzipdoc/functionlistreference.py
@@ -1,271 +1,223 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
 from __future__ import print_function
-from .match import Match
-from .htm2dbk import *
 
-class FunctionListReference:
+from zzipdoc.htm2dbk import html2docbook
+
+
+def _sane(text):
+    return (html2docbook(text)
+            .replace("<link>", "<function>")
+            .replace("</link>", "</function>")
+            .replace("<fu:protospec>", "<funcprototype>")
+            .replace("</fu:protospec>", "</funcprototype>")
+            .replace("<fu:prespec>", "<funcdef>")
+            .replace("</fu:prespec>", "")
+            .replace("<fu:namespec>", "")
+            .replace("</fu:namespec>", "</funcdef>")
+            .replace("</fu:callspec>", "</paramdef>")
+            .replace("<fu:callspec>", "<paramdef>"))
+
+
+class FunctionListReference(object):
     """ Creating a docbook-style <reference> list of <refentry> parts
     that will each be translated into a unix manual page in a second step """
-    def __init__(self, o = None):
-        self.o = o
+
+    def __init__(self, version, package):
+        self.version = version
+        self.package = package
         self.pages = []
         self.entry = None
+
     def cut(self):
-        if not self.entry: return
-        self.pages += [ self.entry ]
+        if not self.entry:
+            return
+        self.pages.append(self.entry)
         self.entry = None
+
     def add(self, entry):
-        name = entry.get_name()
-        description = entry.body_xml_text(name)
-        funcsynopsis = entry.head_xml_text()
+        name = entry.name
+        description = entry.body.xml_text(name)
+        funcsynopsis = str(entry.head)
         if not funcsynopsis:
             print("no funcsynopsis for", name)
             return
         if self.entry is None:
-            self.entry = FunctionListRefEntry(entry, self.o)
-            self.entry.funcsynopsisinfo = entry.get_mainheader()
-            self.entry.refpurpose = entry.get_title()
-            self.entry.refentrytitle = entry.get_name()
-            # self.entry.refname = entry.get_name()
-        self.entry.funcsynopsis_list += [ funcsynopsis ]
-        self.entry.description_list += [ description ]
-        self.entry.refname_list += [ name ]
-        if entry.list_seealso():
-            for item in entry.list_seealso():
-                if item not in self.entry.seealso_list:
-                    self.entry.seealso_list += [ item ]
-    def get_title(self):
-        return self.o.package+" Function List"
-    def xml_text(self):
-        T = "<reference><title>"+self.get_title()+"</title>\n"
+            self.entry = FunctionListRefEntry(entry, self.version, self.package)
+            self.entry.funcsynopsisinfo = entry.mainheader
+            self.entry.refpurpose = entry.title
+            self.entry.refentrytitle = entry.name
+            # self.entry.refname = entry.name
+        self.entry.funcsynopsis_list += [funcsynopsis]
+        self.entry.description_list += [description]
+        self.entry.refname_list += [name]
+        for item in entry.list_seealso:
+            if item not in self.entry.seealso_list:
+                assert item
+                self.entry.seealso_list += [item]
+
+    @property
+    def title(self):
+        return self.package + " Function List"
+
+    def __str__(self):
+        T = "<reference><title>" + self.title + "</title>\n"
         for item in self.pages:
             text = item.refentry_text()
-            if not text: "OOPS, no text for", item.name ; continue
-            T += self.sane(text)
+            if not text:
+                print("OOPS, no text for", item.name)
+                continue
+            T += _sane(text)
         T += "</reference>\n"
         return T
-    def sane(self, text):
-        return (html2docbook(text)
-                .replace("<link>","<function>")
-                .replace("</link>","</function>")
-                .replace("<fu:protospec>","<funcprototype>")
-                .replace("</fu:protospec>","</funcprototype>")
-                .replace("<fu:prespec>","<funcdef>")
-                .replace("</fu:prespec>","")
-                .replace("<fu:namespec>","")
-                .replace("</fu:namespec>","</funcdef>")
-                .replace("</fu:callspec>","</paramdef>")
-                .replace("<fu:callspec>","<paramdef>")) 
 
-    
-class FunctionListRefEntry:
-    def __init__(self, func, o):
+
+class FunctionListRefEntry(object):
+    def __init__(self, func, version, package):
         """ initialize the fields needed for a man page entry - the fields are
            named after the docbook-markup that encloses (!!) the text we store
            the entries like X.refhint = "hello" will be printed therefore as
            <refhint>hello</refhint>. Names with underscores are only used as
            temporaries but they are memorized, perhaps for later usage. """
-        self.name = func.get_name()
-        self.refhint = "\n<!--========= "+self.name+" (3) ============-->\n"
-        self.refentry = None
-        self.refentry_date = o.version.strip()        #! //refentryinfo/date
-        self.refentry_productname = o.package.strip() #! //refentryinfo/prod*
-        self.refentry_title = None                    #! //refentryinfo/title
-        self.refentryinfo = None                      #! override
-        self.manvolnum = "3"                         # //refmeta/manvolnum
-        self.refentrytitle = None                    # //refmeta/refentrytitle
-        self.refmeta = None                          # override
-        self.refpurpose = None                       # //refnamediv/refpurpose
-        self.refname = None                          # //refnamediv/refname
+        self.name = func.name
+        self.refhint = "\n<!--========= " + self.name + " (3) ============-->\n"
+        self.refentry_date = version.strip()  # ! //refentryinfo/date
+        self.refentry_productname = package.strip()  # ! //refentryinfo/prod*
+        self.manvolnum = "3"  # //refmeta/manvolnum
+        self.refentrytitle = None  # //refmeta/refentrytitle
+        self.refpurpose = None  # //refnamediv/refpurpose
         self.refname_list = []
-        self.refnamediv = None                       # override
-        self.mainheader = func.get_mainheader()
-        self.includes = func.get_includes()
-        self.funcsynopsisinfo = ""       # //funcsynopsisdiv/funcsynopsisinfo
-        self.funcsynopsis = None         # //funcsynopsisdiv/funcsynopsis
+        self.mainheader = func.mainheader
+        self.includes = func.includes
+        self.funcsynopsisinfo = ""  # //funcsynopsisdiv/funcsynopsisinfo
         self.funcsynopsis_list = []
-        self.description = None
         self.description_list = []
         # optional sections
-        self.authors_list = []           # //sect1[authors]/listitem
-        self.authors = None              # override
-        self.copyright = None
-        self.copyright_list = []
-        self.seealso = None
+        self.authors_list = []  # //sect1[authors]/listitem
         self.seealso_list = []
-        if  func.list_seealso():
-            for item in func.list_seealso():
-                self.seealso_list += [ item ]
+        for item in func.list_seealso:
+            assert item
+            self.seealso_list += [item]
         self.file_authors = None
-        if  func.get_authors():
-            self.file_authors = func.get_authors()
-            self.authors_list += [ self.file_authors ]
-        self.file_copyright = None
-        if  func.get_copyright():
-            self.file_copyright = func.get_copyright()
-            self.copyright_list += [ self.file_copyright ]
-    #fu
+        if func.authors:
+            self.file_authors = func.authors
+            assert self.file_authors
+            self.authors_list += [self.file_authors]
+        self.file_copyright = ""
+        if func.copyright:
+            self.file_copyright = func.copyright
+            assert self.file_copyright
+
+    @property
     def refentryinfo_text(self):
         """ the manvol formatter wants to render a footer line and header line
             on each manpage and such info is set in <refentryinfo> """
-        if self.refentryinfo:
-            return self.refentryinfo
-        if self.refentry_date and \
-           self.refentry_productname and \
-           self.refentry_title: return (
-            "\n <date>"+self.refentry_date+"</date>"+ 
-            "\n <productname>"+self.refentry_productname+"</productname>"+
-            "\n <title>"+self.refentry_title+"</title>")
-        if self.refentry_date and \
-           self.refentry_productname: return (
-            "\n <date>"+self.refentry_date+"</date>"+ 
-            "\n <productname>"+self.refentry_productname+"</productname>")
+        if self.refentry_date and self.refentry_productname:
+            return (
+                    "\n <date>" + self.refentry_date + "</date>" +
+                    "\n <productname>" + self.refentry_productname + "</productname>")
         return ""
+
+    @property
     def refmeta_text(self):
         """ the manvol formatter needs to know the filename of the manpage to
             be made up and these parts are set in <refmeta> actually """
-        if self.refmeta:
-            return self.refmeta
         if self.manvolnum and self.refentrytitle:
             return (
-                "\n <refentrytitle>"+self.refentrytitle+"</refentrytitle>"+
-                "\n <manvolnum>"+self.manvolnum+"</manvolnum>")
+                    "\n <refentrytitle>" + self.refentrytitle + "</refentrytitle>" +
+                    "\n <manvolnum>" + self.manvolnum + "</manvolnum>")
         if self.manvolnum and self.name:
             return (
-                "\n <refentrytitle>"+self.name+"</refentrytitle>"+
-                "\n <manvolnum>"+self.manvolnum+"</manvolnum>")
+                    "\n <refentrytitle>" + self.name + "</refentrytitle>" +
+                    "\n <manvolnum>" + self.manvolnum + "</manvolnum>")
         return ""
+
+    @property
     def refnamediv_text(self):
         """ the manvol formatter prints a header line with a <refpurpose> line
             and <refname>'d functions that are described later. For each of
             the <refname>s listed here, a mangpage is generated, and for each
             of the <refname>!=<refentrytitle> then a symlink is created """
-        if self.refnamediv:
-            return self.refnamediv
-        if self.refpurpose and self.refname:
-            return ("\n <refname>"+self.refname+'</refname>'+
-                    "\n <refpurpose>"+self.refpurpose+" </refpurpose>")
         if self.refpurpose and self.refname_list:
             T = ""
             for refname in self.refname_list:
-                T += "\n <refname>"+refname+'</refname>'
-            T += "\n <refpurpose>"+self.refpurpose+" </refpurpose>"
+                T += "\n <refname>" + refname + '</refname>'
+            T += "\n <refpurpose>" + self.refpurpose + " </refpurpose>"
             return T
         return ""
+
+    @property
     def funcsynopsisdiv_text(self):
         """ refsynopsisdiv shall be between the manvol mangemaent information
             and the reference page description blocks """
-        T=""
-        if self.funcsynopsis:
-            T += "\n<funcsynopsis>"
-            if self.funcsynopsisinfo:
-                T += "\n<funcsynopsisinfo>"+    self.funcsynopsisinfo + \
-                     "\n</funcsynopsisinfo>\n"
-            T += self.funcsynopsis + \
-                 "\n</funcsynopsis>\n"
+        T = ""
         if self.funcsynopsis_list:
             T += "\n<funcsynopsis>"
             if self.funcsynopsisinfo:
-                T += "\n<funcsynopsisinfo>"+    self.funcsynopsisinfo + \
+                T += "\n<funcsynopsisinfo>" + self.funcsynopsisinfo + \
                      "\n</funcsynopsisinfo>\n"
             for funcsynopsis in self.funcsynopsis_list:
                 T += funcsynopsis
             T += "\n</funcsynopsis>\n"
-        #fi
         return T
+
+    @property
     def description_text(self):
         """ the description section on a manpage is the main part. Here
             it is generated from the per-function comment area. """
-        if self.description:
-            return self.description
-        if self.description_list:
-            T = ""
-            for description in self.description_list:
-                if not description: continue
-                T += description
-            if T.strip() != "": return T
-        return "<para>(missing description)</para>"
+        return "".join(self.description_list).strip()\
+               or "<para>(missing description)</para>"
+
+    @property
     def authors_text(self):
         """ part of the footer sections on a manpage and a description of
             original authors. We prever an itimizedlist to let the manvol
             show a nice vertical aligment of authors of this ref item """
-        if self.authors:
-            return self.authors
         if self.authors_list:
-            T = "<itemizedlist>"
-            previous=""
-            for authors in self.authors_list:
-                if not authors: continue
-                if previous == authors: continue
-                T += "\n <listitem><para>"+authors+"</para></listitem>"
-                previous = authors
-            T += "</itemizedlist>"
-            return T
-        if self.authors:
-            return self.authors
-        return ""
-    def copyright_text(self):
-        """ the copyright section is almost last on a manpage and purely
-            optional. We list the part of the per-file copyright info """
-        if self.copyright:
-            return self.copyright
-        """ we only return the first valid instead of merging them """
-        if self.copyright_list:
-            T = ""
-            for copyright in self.copyright_list:
-                if not copyright: continue
-                return copyright # !!!
+            return "<itemizedlist>"\
+                + ''.join("\n <listitem><para>" + author + "</para></listitem>"
+                          for author in sorted(set(self.authors_list)))\
+                + "</itemizedlist>"
         return ""
+
+    @property
     def seealso_text(self):
         """ the last section on a manpage is called 'SEE ALSO' usually and
             contains a comma-separated list of references. Some manpage
             viewers can parse these and convert them into hyperlinks """
-        if self.seealso:
-            return self.seealso
-        if self.seealso_list:
-            T = ""
-            for seealso in self.seealso_list:
-                if not seealso: continue
-                if T: T += ", "
-                T += seealso
-            if T: return T
-        return ""
+        return ', '.join(self.seealso_list)
+
     def refentry_text(self, id=None):
         """ combine fields into a proper docbook refentry """
-        if id is None:
-            id = self.refentry
         if id:
-            T = '<refentry id="'+id+'">'
+            T = '<refentry id="' + id + '">'
         else:
-            T = '<refentry>' # this is an error
-           
-        if self.refentryinfo_text():
-            T += "\n<refentryinfo>"+       self.refentryinfo_text()+ \
+            T = '<refentry>'  # this is an error
+
+        if self.refentryinfo_text:
+            T += "\n<refentryinfo>" + self.refentryinfo_text + \
                  "\n</refentryinfo>\n"
-        if self.refmeta_text():
-            T += "\n<refmeta>"+            self.refmeta_text() + \
-                 "\n</refmeta>\n" 
-        if self.refnamediv_text():
-            T += "\n<refnamediv>"+         self.refnamediv_text() + \
+        if self.refmeta_text:
+            T += "\n<refmeta>" + self.refmeta_text + \
+                 "\n</refmeta>\n"
+        if self.refnamediv_text:
+            T += "\n<refnamediv>" + self.refnamediv_text + \
                  "\n</refnamediv>\n"
-        if self.funcsynopsisdiv_text():     
-            T += "\n<refsynopsisdiv>\n"+   self.funcsynopsisdiv_text()+ \
+        if self.funcsynopsisdiv_text:
+            T += "\n<refsynopsisdiv>\n" + self.funcsynopsisdiv_text + \
                  "\n</refsynopsisdiv>\n"
-        if self.description_text():
+        if self.description_text:
             T += "\n<refsect1><title>Description</title> " + \
-                 self.description_text() + "\n</refsect1>"
-        if self.authors_text():
+                 self.description_text + "\n</refsect1>"
+        if self.authors_text:
             T += "\n<refsect1><title>Author</title> " + \
-                 self.authors_text() + "\n</refsect1>"
-        if self.copyright_text():
+                 self.authors_text + "\n</refsect1>"
+        if self.file_copyright:
             T += "\n<refsect1><title>Copyright</title> " + \
-                 self.copyright_text() + "\n</refsect1>\n"
-        if self.seealso_text():
+                 self.file_copyright + "\n</refsect1>\n"
+        if self.seealso_text:
             T += "\n<refsect1><title>See Also</title><para> " + \
-                 self.seealso_text() + "\n</para></refsect1>\n"
+                 self.seealso_text + "\n</para></refsect1>\n"
 
-        T +=  "\n</refentry>\n"
+        T += "\n</refentry>\n"
         return T
-    #fu
-#end
diff --git a/docs/zzipdoc/functionprototype.py b/docs/zzipdoc/functionprototype.py
index b7f03cf..30f11c4 100644
--- a/docs/zzipdoc/functionprototype.py
+++ b/docs/zzipdoc/functionprototype.py
@@ -1,60 +1,28 @@
-from .match import Match
+import re
 
-class FunctionPrototype:
+
+class FunctionPrototype(object):
     """ takes a single function prototype line (cut from some source file)
     and parses it into the relevant portions 'prespec', 'namespec' and
     'callspec'. Additionally we present 'name' from the namespec that is
     usually used as the filename stem for a manual page """
-    def __init__(self, functionheader = None):
+    def __init__(self, functionheader=None):
         self.functionheader = functionheader
-        self.prespec = None
-        self.namespec = None
-        self.callspec = None
-        self.name = None
-    def get_functionheader(self):
-        return self.functionheader
-    def get_prototype(self):
-        if self.functionheader is None:
-            return None
-        return self.functionheader.get_prototype()
-    def get_filename(self):
-        if self.functionheader is None:
-            return None
-        return self.functionheader.get_filename()
-    def parse(self, functionheader = None):
-        if functionheader is not None:
-            self.functionheader = functionheader
-        if self.functionheader is None:
-            return False
-        found = Match()
-        prototype = self.get_prototype()
-        if prototype & found(r"(?s)^(.*[^.])"
-                             r"\b(\w[\w.]*\w)\b"
-                             r"(\s*\(.*)$"):
-            self.prespec = found.group(1).lstrip()
-            self.namespec = found.group(2)
-            self.callspec = found.group(3).lstrip()
-            self.name = self.namespec.strip()
-            return True
-        return False
-    def _assert_parsed(self):
-        if self.name is None:
-            return self.parse()
-        return True
-    def get_prespec(self):
-        if not self._assert_parsed(): return None
-        return self.prespec
-    def get_namespec(self):
-        if not self._assert_parsed(): return None
-        return self.namespec
-    def get_callspec(self):
-        if not self._assert_parsed(): return None
-        return self.callspec
-    def get_name(self):
-        if not self._assert_parsed(): return None
-        return self.name
-    def xml_text(self):
-        if not self.namespec: return self.namespec
+        self.prototype = self.functionheader.prototype
+        self.filename = self.functionheader.filename
+        found = re.search(r"(?s)^(.*[^.])"
+                          r"\b(\w[\w.]*\w)\b"
+                          r"(\s*\(.*)$",
+                          self.prototype)
+        if not found:
+            raise Exception("Function prototype regex did not grab anything")
+
+        self.prespec = found.group(1).lstrip()
+        self.namespec = found.group(2)
+        self.callspec = found.group(3).lstrip()
+        self.name = self.namespec.strip()
+
+    def __str__(self):
         return ("<fu:protospec><fu:prespec>"+self.prespec+"</fu:prespec>"+
                 "<fu:namespec>"+self.namespec+"</fu:namespec>"+
                 "<fu:callspec>"+self.callspec+"</fu:callspec></fu:protospec>")
diff --git a/docs/zzipdoc/htm2dbk.py b/docs/zzipdoc/htm2dbk.py
index 1b8749e..8267b14 100644
--- a/docs/zzipdoc/htm2dbk.py
+++ b/docs/zzipdoc/htm2dbk.py
@@ -1,158 +1,126 @@
 #! /usr/bin/env python
 
 """
-this file converts simple html text into a docbook xml variant. 
+this file converts simple html text into a docbook xml variant.
 The mapping of markups and links is far from perfect. But all we
 want is the docbook-to-pdf converter and similar technology being
 present in the world of docbook-to-anything converters. """
 
 from __future__ import absolute_import, print_function
 
-from datetime import date
-from .match import Match as m
+import re
+
 import sys
 
-class htm2dbk_conversion_base:
-    regexlist = [
-        m()("</[hH]2>(.*)", "m") >> "</title>\n<subtitle>\\1</subtitle>",
-        m()("<[hH]2>") >> "<sect1 id=\"--filename--\"><title>",
-        m()("<[Pp]([> ])","m") >> "<para\\1",
-        m()("</[Pp]>") >> "</para>",
-        m()("<(pre|PRE)>") >> "<screen>",
-        m()("</(pre|PRE)>") >> "</screen>",
-        m()("<[hH]3>") >> "<sect2><title>",
-        m()("</[hH]3>((?:.(?!<sect2>))*.?)", "s") >> "</title>\\1</sect2>",
-        m()("<!doctype [^<>]*>","s") >> "",
-        m()("<!DOCTYPE [^<>]*>","s") >> "",
-        m()("(<\w+\b[^<>]*\swidth=)(\d+\%)","s") >> "\\1\"\\2\"",
-        m()("(<\w+\b[^<>]*\s\w+=)(\d+)","s") >> "\\1\"\\2\"",
-        m()("&&") >> "\&amp\;\&amp\;",
-        m()("\$\<") >> "\$\&lt\;",
-        m()("&(\w+[\),])") >> "\&amp\;\\1",
-        m()("(</?)span(\s[^<>]*)?>","s") >> "\\1phrase\\2>",
-        m()("(</?)small(\s[^<>]*)?>","s") >> "\\1note\\2>",
-        m()("(</?)(b|em|i)>")>> "\\1emphasis>",
-        m()("(</?)(li)>") >> "\\1listitem>",
-        m()("(</?)(ul)>") >> "\\1itemizedlist>",
-        m()("(</?)(ol)>") >> "\\1orderedlist>",
-        m()("(</?)(dl)>") >> "\\1variablelist>",
-        m()("<dt\b([^<>]*)>","s") >> "<varlistentry\\1><term>",
-        m()("</dt\b([^<>]*)>","s") >> "</term>",
-        m()("<dd\b([^<>]*)>","s") >> "<listitem\\1>",
-        m()("</dd\b([^<>]*)>","s") >> "</listitem></varlistentry>",
-        m()("<table\b([^<>]*)>","s")
-        >> "<informaltable\\1><tgroup cols=\"2\"><tbody>",
-        m()("</table\b([^<>]*)>","s") >> "</tbody></tgroup></informaltable>",
-        m()("(</?)tr(\s[^<>]*)?>","s") >> "\\1row\\2>",
-        m()("(</?)td(\s[^<>]*)?>","s") >> "\\1entry\\2>",
-        m()("<informaltable\b[^<>]*>\s*<tgroup\b[^<>]*>\s*<tbody>"+
-          "\s*<row\b[^<>]*>\s*<entry\b[^<>]*>\s*<informaltable\b","s")
-        >> "<informaltable",
-        m()("</informaltable>\s*</entry>\s*</row>"+
-          "\s*</tbody>\s*</tgroup>\s*</informaltable>", "s")
-        >> "</informaltable>",
-        m()("(<informaltable[^<>]*\swidth=\"100\%\")","s") >> "\\1 pgwide=\"1\"",
-        m()("(<tbody>\s*<row[^<>]*>\s*<entry[^<>]*\s)(width=\"50\%\")","s")
-        >> "<colspec colwidth=\"1*\" /><colspec colwidth=\"1*\" />\n\\1\\2",
-        m()("<nobr>([\'\`]*)<tt>") >> "<cmdsynopsis>\\1",
-        m()("</tt>([\'\`]*)</nobr>") >> "\\1</cmdsynopsis>",
-        m()("<nobr><(?:tt|code)>([\`\"\'])") >> "<cmdsynopsis>\\1",
-        m()("<(?:tt|code)><nobr>([\`\"\'])") >> "<cmdsynopsis>\\1",
-        m()("([\`\"\'])</(?:tt|code)></nobr>") >> "\\1</cmdsynopsis>",
-        m()("([\`\"\'])</nobr></(?:tt|code)>") >> "\\1</cmdsynopsis>",
-        m()("(</?)tt>") >> "\\1constant>",
-        m()("(</?)code>") >> "\\1literal>",
-        m()(">([^<>]+)<br>","s") >> "><highlights>\\1</highlights>",
-        m()("<br>") >> "<br />",
-        #        m()("<date>") >> "<sect1info><date>",
-        #        m()("</date>") >> "</date></sect1info>",
-        m()("<reference>") >> "<reference id=\"reference\">" >> 1,
-        m()("<a\s+href=\"((?:http|ftp|mailto):[^<>]+)\"\s*>((?:.(?!</a>))*.)</a>"
-          ,"s") >> "<ulink url=\"\\1\">\\2</ulink>",
-        m()("<a\s+href=\"zziplib.html\#([\w_]+)\"\s*>((?:.(?!</a>))*.)</a>","s")
-        >> "<link linkend=\"$1\">$2</link>",
-        m()("<a\s+href=\"(zziplib.html)\"\s*>((?:.(?!</a>))*.)</a>","s")
-        >> "<link linkend=\"reference\">$2</link>",
-        m()("<a\s+href=\"([\w-]+[.]html)\"\s*>((?:.(?!</a>))*.)</a>","s")
-        >> "<link linkend=\"\\1\">\\2</link>",
-        m()("<a\s+href=\"([\w-]+[.](?:h|c|am|txt))\"\s*>((?:.(?!</a>))*.)</a>"
-          ,"s") >> "<ulink url=\"file:\\1\">\\2</ulink>",
-        m()("<a\s+href=\"([A-Z0-9]+[.][A-Z0-9]+)\"\s*>((?:.(?!</a>))*.)</a>","s")
-        >> "<ulink url=\"file:\\1\">\\2</ulink>"
-        # m()("(</?)subtitle>") >> "\\1para>"
-        # $_ .= "</sect1>" if /<sect1[> ]/
-        ]
-    regexlist2 = [
-        m()(r"<br\s*/?>") >> "",
-        m()(r"(</?)em>") >> r"\1emphasis>",
-        m()(r"<code>") >> "<userinput>",
-        m()(r"</code>") >> "</userinput>",
-        m()(r"<link>") >> "<function>",
-        m()(r"</link>") >> "</function>",
-        m()(r"(?s)\s*</screen>") >> "</screen>",
-        # m()(r"<ul>") >> "</para><programlisting>\n",
-        # m()(r"</ul>") >> "</programlisting><para>",
-        m()(r"<ul>") >> "<itemizedlist>",
-        m()(r"</ul>") >> "</itemizedlist>",
-        # m()(r"<li>") >> "",
-        # m()(r"</li>") >> ""
-        m()(r"<li>") >> "<listitem><para>",
-        m()(r"</li>") >> "</para></listitem>\n",
-        ]
-class htm2dbk_conversion(htm2dbk_conversion_base):
-    def __init__(self):
-        self.version = "" # str(date.today)
-        self.filename = "."
-    def convert(self,text): # $text
-        txt = text.replace("<!--VERSION-->", self.version)
-        for conv in self.regexlist:
-            txt &= conv
-        return txt.replace("--filename--", self.filename)
-    def convert2(self,text): # $text
-        txt = text.replace("<!--VERSION-->", self.version)
-        for conv in self.regexlist:
-            txt &= conv
-        return txt
-
-class htm2dbk_document(htm2dbk_conversion):
+_regexlist = [
+    ("(?m)</[hH]2>(.*)", "</title>\n<subtitle>\\1</subtitle>"),
+    ("<[hH]2>", "<sect1 id=\"--filename--\"><title>"),
+    ("(?m)<[Pp]([> ])", "<para\\1"),
+    ("</[Pp]>", "</para>"),
+    ("<(pre|PRE)>", "<screen>"),
+    ("</(pre|PRE)>", "</screen>"),
+    ("<[hH]3>", "<sect2><title>"),
+    ("(?s)</[hH]3>((?:.(?!<sect2>))*.?)", "</title>\\1</sect2>"),
+    ("(?s)<!doctype [^<>]*>", ""),
+    ("(?s)<!DOCTYPE [^<>]*>", ""),
+    (r"(?s)(<\w+\b[^<>]*\swidth=)(\d+\%)", "\\1\"\\2\""),
+    (r"(?s)(<\w+\b[^<>]*\s\w+=)(\d+)", "\\1\"\\2\""),
+    ("&&", "&amp;&amp;"),
+    (r"\$\<", "$&lt;"),
+    (r"&(\w+[\),])", r"&amp;\1"),
+    (r"(?s)(</?)span(\s[^<>]*)?>", r"\1phrase\2>"),
+    (r"(?s)(</?)small(\s[^<>]*)?>", r"\1note\2>"),
+    ("(</?)(b|em|i)>", r"\1emphasis>"),
+    ("(</?)(li)>", r"\1listitem>"),
+    ("(</?)(ul)>", r"\1itemizedlist>"),
+    ("(</?)(ol)>", r"\1orderedlist>"),
+    ("(</?)(dl)>", r"\1variablelist>"),
+    (r"(?s)<dt\b([^<>]*)>", r"<varlistentry\1><term>"),
+    (r"(?s)</dt\b([^<>]*)>", "</term>"),
+    (r"(?s)<dd\b([^<>]*)>", r"<listitem\1>"),
+    (r"(?s)</dd\b([^<>]*)>", "</listitem></varlistentry>"),
+    (r"(?s)<table\b([^<>]*)>", "<informaltable\\1><tgroup cols=\"2\"><tbody>"),
+    (r"(?s)</table\b([^<>]*)>", "</tbody></tgroup></informaltable>"),
+    (r"(?s)(</?)tr(\s[^<>]*)?>", r"\1row\2>"),
+    (r"(?s)(</?)td(\s[^<>]*)?>", r"\1entry\2>"),
+    (r"(?s)<informaltable\b[^<>]*>\s*<tgroup\b[^<>]*>\s*<tbody>\s*<row\b[^<>]*>\s*<entry\b[^<>]*>\s*<informaltable\b", "<informaltable"),
+    (r"(?s)</informaltable>\s*</entry>\s*</row>\s*</tbody>\s*</tgroup>\s*</informaltable>", "</informaltable>"),
+    ("(?s)(<informaltable[^<>]*\\swidth=\"100%\")", "\\1 pgwide=\"1\""),
+    ("(?s)(<tbody>\\s*<row[^<>]*>\\s*<entry[^<>]*\\s)(width=\"50%\")", "<colspec colwidth=\"1*\" /><colspec colwidth=\"1*\" />\n\\1\\2"),
+    ("<nobr>(['`]*)<tt>", "<cmdsynopsis>\\1"),
+    ("</tt>(['`]*)</nobr>", "\\1</cmdsynopsis>"),
+    ("<nobr><(?:tt|code)>([`\"'])", "<cmdsynopsis>\\1"),
+    ("<(?:tt|code)><nobr>([`\"'])", "<cmdsynopsis>\\1"),
+    ("([`\"'])</(?:tt|code)></nobr>", "\\1</cmdsynopsis>"),
+    ("([`\"'])</nobr></(?:tt|code)>", "\\1</cmdsynopsis>"),
+    ("(</?)tt>", "\\1constant>"),
+    ("(</?)code>", "\\1literal>"),
+    ("(?s)>([^<>]+)<br>", "><highlights>\\1</highlights>"),
+    ("<br>", "<br />"),
+    # ("<date>", "<sect1info><date>"),
+    # ("</date>", "</date></sect1info>"),
+    ("<reference>", "<reference id=\"reference\">"),
+    ("(?s)<a\\s+href=\"((?:http|ftp|mailto):[^<>]+)\"\\s*>((?:.(?!</a>))*.)</a>", "<ulink url=\"\\1\">\\2</ulink>"),
+    ("(?s)<a\\s+href=\"zziplib.html#([\\w_]+)\"\\s*>((?:.(?!</a>))*.)</a>", "<link linkend=\"\\1\">\\2</link>"),
+    ("(?s)<a\\s+href=\"(zziplib.html)\"\\s*>((?:.(?!</a>))*.)</a>", "<link linkend=\"reference\">\\2</link>"),
+    ("(?s)<a\\s+href=\"([\\w-]+[.]html)\"\\s*>((?:.(?!</a>))*.)</a>", "<link linkend=\"\\1\">\\2</link>"),
+    ("(?s)<a\\s+href=\"([\\w-]+[.](?:h|c|am|txt))\"\\s*>((?:.(?!</a>))*.)</a>", "<ulink url=\"file:\\1\">\\2</ulink>"),
+    ("(?s)<a\\s+href=\"([A-Z0-9]+[.][A-Z0-9]+)\"\\s*>((?:.(?!</a>))*.)</a>", "<ulink url=\"file:\\1\">\\2</ulink>"),
+    # ("(</?)subtitle>", "\\1para>"),
+    # $_ .= "</sect1>" if /<sect1[> ]/
+]
+
+
+def html2docbook(text, ):
+    """ the C comment may contain html markup - simulate with docbook tags """
+    txt = text.replace("<!--VERSION-->", '')
+    for regex, replace in _regexlist:
+        txt = re.sub(regex, replace, txt)
+    return txt
+
+
+class htm2dbk_document(object):
     """ create document, add(text) and get the value() """
     doctype = (
-        '<!DOCTYPE book PUBLIC "-//OASIS//DTD'+
-        ' DocBook XML V4.1.2//EN"'+"\n"+
-        '       "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">'+
-        "\n")
-    book_start = '<book><chapter><title>Documentation</title>'+"\n"
-    book_end_chapters = '</chapter>'+"\n"
-    book_end = '</book>'+"\n"
+            '<!DOCTYPE book PUBLIC "-//OASIS//DTD' +
+            ' DocBook XML V4.1.2//EN"' + "\n" +
+            '       "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">' +
+            "\n")
+    book_start = '<book><chapter><title>Documentation</title>' + "\n"
+    book_end_chapters = '</chapter>' + "\n"
+    book_end = '</book>' + "\n"
+
     def __init__(self):
-        htm2dbk_conversion.__init__(self)
         self.text = self.doctype + self.book_start
-    def add(self,text):
-        if self.text & m()("<reference"):
-            self.text += self.book_end_chapters ; self.book_end_chapters = ""
-        self.text += self.convert(text).replace(
-            "<br />","") & (
-            m()("<link>([^<>]*)</link>") >> "<function>\\1</function>") & (
-            m()("(?s)(<refentryinfo>\s*)<sect1info>" +
-                "(<date>[^<>]*</date>)</sect1info>") >> "\\1\\2")
-    def value(self):
+
+    def add(self, text, filename):
+        if '<reference' in self.text:
+            self.text += self.book_end_chapters
+            self.book_end_chapters = ""
+
+        text = html2docbook(text)\
+            .replace("--filename--", filename)\
+            .replace("<br />", "")
+        text = re.sub("<link>([^<>]*)</link>", r"<function>\1</function>", text)
+        text = re.sub(
+            r"(<refentryinfo>\s*)<sect1info>(<date>[^<>]*</date>)</sect1info>",
+            r"\1\2", text, flags=re.S)
+        self.text += text
+
+    def __str__(self):
         return self.text + self.book_end_chapters + self.book_end
 
+
 def htm2dbk_files(args):
     doc = htm2dbk_document()
     for filename in args:
         try:
-            f = open(filename, "r")
-            doc.filename = filename
-            doc.add(f.read())
-            f.close()
-        except IOError as e:
+            with open(filename, "r") as f:
+                doc.add(f.read(), filename)
+        except IOError:
             print("can not open", filename, file=sys.stderr)
-    return doc.value()
+    return str(doc)
 
-def html2docbook(text):
-    """ the C comment may contain html markup - simulate with docbook tags """
-    return htm2dbk_conversion().convert2(text)
 
 if __name__ == "__main__":
     print(htm2dbk_files(sys.argv[1:]))
diff --git a/docs/zzipdoc/htmldocument.py b/docs/zzipdoc/htmldocument.py
index aefb2e9..9ece867 100644
--- a/docs/zzipdoc/htmldocument.py
+++ b/docs/zzipdoc/htmldocument.py
@@ -1,118 +1,33 @@
 #! /usr/bin/env python
 # -*- coding: UTF-8 -*-
 from __future__ import print_function
-from .match import Match
 
-class HtmlDocument:
+from zzipdoc.document import BaseDocument
+
+
+class HtmlDocument(BaseDocument):
     """ binds some html content page with additional markup - in this
     base version it is just the header information while other variants
     might add navigation items around the content block elements """
-    def __init__(self, o, filename = None):
-        self.o = o
-        self.filename = filename
-        self.title = ""
-        self.meta = []
-        self.style = []
-        self.text = []
-        self.navi = None
-    def meta(self, style):
-        """ add some header meta entry """
-        self.meta += [ meta ]
-        return self
-    def style(self, style):
-        """ add a style block """
-        self.style += [ style ]
-        return self
-    def add(self, text):
-        """ add some content """
-        self.text += [ text ]
-        return self
-    def get_title(self):
-        if self.title: return self.title
-        try:   return self.text[0].get_title()
-        except Exception as e: pass
-        return self.title
-    def _html_meta(self, meta):
-        """ accepts adapter objects with .html_meta() """
-        try:   return meta.html_meta()
-        except Exception as e: pass
-        return str(meta)
-    def _html_style(self, style):
-        """ accepts adapter objects with .html_style() and .xml_style() """
-        ee = None
-        try:   return style.html_style()
-        except Exception as e: ee = e
-        try:   return style.xml_style()
-        except Exception as e: print("HtmlDocument/style", ee, e)
-        try:   return str(style)
-        except Exception as e: print("HtmlDocument/style", e); return ""
-    def _html_text(self, html):
-        """ accepts adapter objects with .html_text() and .xml_text() """
-        ee = None
-        try:   return html.html_text()
-        except Exception as e: ee = e
-        try:   return html.xml_text()
-        except Exception as e: print("HtmlDocument/text", ee, e)
-        try:   return str(html)
-        except Exception as e: print("HtmlDocument/text", e); return "&nbsp;"
-    def navigation(self):
-        if self.navi:
-            return self.navi
-        if self.o.body:
-            try:
-                fd = open(self.o.body, "r")
-                self.navi = fd.read()
-                fd.close()
-                return self.navi
-            except Exception as e:
-                pass
-        return None
+
+    def __init__(self, version):
+        super(HtmlDocument, self).__init__()
+        self.version = version
+
     def html_header(self):
-        navi = self.navigation()
-        if not navi:
-            T = "<html><head>"
-            title = self.get_title()
-            if title:
-                T += "<title>"+title+"</title>"
-            T += "\n"
-            for style in self.style:
-                T += self._html_style(style)
-                T += "\n"
-            return T+"</head><body>"
-        else:
-            title = self.get_title()
-            return navi & (
-                Match(r"<!--title-->") >> " - "+title) & (
-                Match(r"<!--VERSION-->") >> self.o.version) & (
-                Match(r"(?m).*</body></html>") >> "")
+        text = "<html><head>"
+        title = self.title
+        if title:
+            text += "<title>" + title + "</title>"
+        text += "\n"
+        return text + "</head><body>"
+
     def html_footer(self):
-        navi = self.navigation()
-        if not navi:
-            return "</body></html>"
-        else:
-            return navi & (
-                Match(r"(?m)(.*</body></html>)") >> "%&%&%&%\\1") & (
-                Match(r"(?s).*%&%&%&%") >> "")
-    def _filename(self, filename):
-        if filename is not None:
-            self.filename = filename
-        filename = self.filename
-        if not filename & Match(r"\.\w+$"):
-            ext = self.o.html
-            if not ext: ext = "html"
-            filename += "."+ext
-        return filename
-    def save(self, filename = None):
-        filename = self._filename(filename)
-        print("writing '"+filename+"'")
-        try:
-            fd = open(filename, "w")
-            print(self.html_header(), file=fd)
-            for text in self.text:
-                print(self._html_text(text), file=fd)
-            print(self.html_footer(), file=fd)
-            fd.close()
-            return True
-        except IOError as e:
-            print("could not open '"+filename+"'file", e)
-            return False
+        return "</body></html>"
+
+    def save(self, fd):
+        print(self.html_header(), file=fd)
+        for text in self.text:
+            print(text, file=fd)
+        print(self.html_footer(), file=fd)
+
diff --git a/docs/zzipdoc/match.py b/docs/zzipdoc/match.py
deleted file mode 100644
index 5d81609..0000000
--- a/docs/zzipdoc/match.py
+++ /dev/null
@@ -1,91 +0,0 @@
-#! /usr/bin/python
-# -*- coding: utf-8 -*-
-# @creator (C) 2003 Guido U. Draheim
-# @license http://creativecommons.org/licenses/by-nc-sa/2.0/de/
-
-import re
-
-# ---------------------------------------------------------- Regex Match()
-# beware, stupid python interprets backslashes in replace-parts only partially!
-class MatchReplace(object):
-    """ A MatchReplace is a mix of a Python Pattern and a Replace-Template """
-    def __init__(self, matching, template, count = 0, flags = None):
-        """ setup a substition from regex 'matching' into 'template',
-            the replacement count default of 0 will replace all occurrences.
-            The first argument may be a Match object or it is a string that
-            will be turned into one by using Match(matching, flags). """
-        self.template = template
-        MatchReplace.__call__(self, matching, template, count, flags)
-    def __call__(self, matching, template = None, count = 0, flags = None):
-        """ other than __init__ the template may be left off to be unchanged"""
-        if not isinstance(count, int):
-            raise Exception("Shouldn't have count as non int")
-        #if isinstance(count, basestring): # count/flags swapped over?
-        #    flags = count; count = 0
-        if isinstance(matching, Match):
-            self.matching = matching
-        else:
-            self.matching = Match()(matching, flags) ## python 2.4.2 bug
-        if template is not None:
-            self.template = template
-        self.count = count
-    def __and__(self, string):
-        """ z = MatchReplace('foo', 'bar') & 'foo'; assert z = 'bar' """
-        text, self.matching.replaced = \
-              self.matching.regex.subn(self.template, string, self.count)
-        return text
-    def __rand__(self, string):
-        """ z = 'foo' & Match('foo') >> 'bar'; assert z = 'bar' """
-        text, self.matching.replaced = \
-              self.matching.regex.subn(self.template, string, self.count)
-        return text
-    def __iand__(self, string):
-        """ x = 'foo' ; x &= Match('foo') >> 'bar'; assert x == 'bar' """
-        string, self.matching.replaced = \
-                self.matching.regex.subn(self.template, string, self.count)
-        return string
-    def __rshift__(self, count):
-        " shorthand to set the replacement count: Match('foo') >> 'bar' >> 1 "
-        self.count = count ; return self
-    def __rlshift__(self, count):
-        self.count = count ; return self
-
-class Match(object):
-    """ A Match is actually a mix of a Python Pattern and MatchObject """
-    def __init__(self, pattern = None, flags = None):
-        """ flags is a string: 'i' for case-insensitive etc.; it is just
-        short for a regex prefix: Match('foo','i') == Match('(?i)foo') """
-        Match.__call__(self, pattern, flags)
-    def __call__(self, pattern, flags = None):
-        assert isinstance(pattern, str) or pattern is None
-        assert isinstance(flags, str) or flags is None
-        self.replaced = 0 # set by subn() inside MatchReplace
-        self.found = None # set by search() to a MatchObject
-        self.pattern = pattern
-        if pattern is not None:
-            if flags:
-                self.regex = re.compile("(?"+flags+")"+self.pattern)
-            else:
-                self.regex = re.compile(self.pattern)
-        return self
-    def __truth__(self):
-        return self.found is not None
-    def __and__(self, string):
-        self.found = self.regex.search(string)
-        return self.__truth__()
-    def __rand__(self, string):
-        self.found = self.regex.search(string)
-        return self.__truth__()
-    def __rshift__(self, template):
-        return MatchReplace(self, template)
-    def __rlshift__(self, template):
-        return MatchReplace(self, template)
-    def __getitem__(self, index):
-        return self.group(index)
-    def __str__(self):
-        return self.pattern
-    def group(self, index):
-        assert self.found is not None
-        return self.found.group(index)
-    def finditer(self, string):
-        return self.regex.finditer(string)
diff --git a/docs/zzipdoc/options.py b/docs/zzipdoc/options.py
deleted file mode 100644
index 230df40..0000000
--- a/docs/zzipdoc/options.py
+++ /dev/null
@@ -1,23 +0,0 @@
-#! /usr/bin/python
-# -*- coding: utf-8 -*-
-# @creator (C) 2003 Guido U. Draheim
-# @license http://creativecommons.org/licenses/by-nc-sa/2.0/de/
-
-from .match import Match
-
-# use as o.optionname to check for commandline options.
-class Options:
-    var = {}
-    def __getattr__(self, name):
-        return self.var.get(name)
-    def __setattr__(self, name, value):
-        self.var[name] = value
-    def scan(self, optionstring): # option-name or None
-        x = Match()
-        if optionstring & x(r"^--?(\w+)=(.*)"):
-            self.var[x[1]] = x[2] ;  return x[1]
-        if optionstring & x(r"^--?no-(\w+)$"):
-            self.var[x[1]] = "" ; return x[1]
-        if optionstring & x(r"^--?(\w+)$"):
-            self.var[x[1]] = "*"; return x[1]
-        return None
diff --git a/docs/zzipdoc/textfile.py b/docs/zzipdoc/textfile.py
index 51728af..9b1104e 100644
--- a/docs/zzipdoc/textfile.py
+++ b/docs/zzipdoc/textfile.py
@@ -1,46 +1,12 @@
-def _src_to_xml(text):
-    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt")
+import cgi
 
-class TextFile:
-    def __init__(self, filename = None):
-        self.filename = filename
-        self.src_text = None
-        self.xml_text = None
-    def parse(self, filename = None):
-        if filename is not None:
-            self.filename = filename
-        if self.filename is None:
-            return False
-        try:
-            fd = open(self.filename, "r")
+
+class TextFile(object):
+    def __init__(self, filename):
+        self.filename = filename  # type: str
+        with open(filename, "r") as fd:
             self.src_text = fd.read()
-            fd.close()
-            return True
-        except IOError as e:
-            pass
-        return False
-    def assert_src_text(self):
-        if self.src_text: return True
-        return self.parse()
-    def assert_xml_text(self):
-        if self.xml_text: return True
-        if not self.assert_src_text(): return False
-        self.xml_text = _src_to_xml(self.src_text)
-    def get_src_text(self):
-        self.assert_src_text()
-        return self.src_text
-    def get_xml_text(self):
-        self.assert_xml_text()
+        self.xml_text = cgi.escape(self.src_text)  # type: str
+
+    def __str__(self):
         return self.xml_text
-    def get_filename(self):
-        return self.filename
-    def line_xml_text(self, offset):
-        self._line(self.xml_text, offset)
-    def line_src_text(self, offset):
-        self._line(self.src_text, offset)
-    def _line(self, text, offset):
-        line = 1
-        for x in xrange(0,offset):
-            if x == "\n":
-                line += 1
-        return line
diff --git a/docs/zzipdoc/textfileheader.py b/docs/zzipdoc/textfileheader.py
index 099b618..06cdb43 100644
--- a/docs/zzipdoc/textfileheader.py
+++ b/docs/zzipdoc/textfileheader.py
@@ -1,48 +1,41 @@
 from __future__ import print_function
-from .match import Match
+import re
 
-class TextFileHeader:
+from zzipdoc.textfile import TextFile
+
+
+class TextFileHeader(object):
     """ scan for a comment block at the source file start and fill the
     inner text into self.comment - additionally scan for the first
     #include statement and put the includename into self.mainheader
     (TextFileHeader re-exports all => TextFile methods for processing)"""
-    def __init__(self, textfile = None):
-        self.textfile = textfile # TextFile
-        self.comment = ""    # src'style
-        self.mainheader = ""     # src'style
-    def parse(self, textfile = None):
-        if textfile is not None:
-            self.textfile = textfile
-        if self.textfile is None:
-            return False
-        x = Match()
-        text = self.textfile.get_src_text()
+    def __init__(self, textfile):  # type: (TextFile) -> None
+        self.textfile = textfile
+        self.comment = ""
+        self.mainheader = ""
+
+        text = textfile.src_text
         if not text:
-            print("nonexistent file:", self.textfile.get_filename())
-            return False
-        if text & x(r"(?s)[/][*]+(\s(?:.(?!\*\/))*.)\*\/"
-                    r"(?:\s*\#(?:define|ifdef|endif)[ ]*\S*[ ]*\S*)*"
-                    r"(\s*\#include\s*<[^<>]*>(?:\s*//[^\n]*)?)"):
-            self.comment = x[1]
-            self.mainheader = x[2].strip()
-        elif text & x(r"(?s)[/][*]+(\s(?:.(?!\*\/))*.)\*\/"):
-            self.comment = x[1]
-        elif text & x(r"(?s)(?:\s*\#(?:define|ifdef|endif)[ ]*\S*[ ]*\S*)*"
-                      r"(\s*\#include\s*<[^<>]*>(?:\s*//[^\n]*)?)"):
-            self.mainheader = x[1].strip()
-        return True
-    def src_mainheader(self):
-        return self.mainheader
-    def src_filecomment(self):
-        return self.comment
+            raise Exception("nonexistent file:", textfile.filename)
+
+        comment = re.search(r"(?s)[/][*]+(\s(?:.(?!\*/))*.)\*/", text)
+        if comment:
+            self.comment = comment.group(1)
+
+        mainheader = re.search(r"(?s)(?:\s*#(?:define|ifdef|endif)[ ]*\S*[ ]*\S*)*"
+                               r"(\s*#include\s*<[^<>]*>(?:\s*//[^\n]*)?)",
+                               text)
+        if mainheader:
+            self.mainheader = mainheader.group(1).strip()
+
     # re-export textfile functions - allows textfileheader to be used instead
-    def get_filename(self):
-        return self.textfile.get_filename()
-    def get_src_text(self):
-        return self.textfile.get_src_text()
-    def get_xml_text(self):
-        return self.textfile.get_src_text()
-    def line_src__text(self, offset):
-        return self.textfile.line_src_text(offset)
-    def line_xml__text(self, offset):
-        return self.textfile.line_xml_text(offset)
+    @property
+    def filename(self):
+        return self.textfile.filename
+
+    @property
+    def src_text(self):
+        return self.textfile.src_text
+
+    def __str__(self):
+        return self.src_text

From 09a14fd7abcbc0f127fe2913153552d6729d8676 Mon Sep 17 00:00:00 2001
From: Score_Under <seejay.11@gmail.com>
Date: Sun, 25 Aug 2019 14:00:15 +0100
Subject: [PATCH 3/3] Remove extra docbook renaming step

---
 docs/Makefile.am         |  6 +++---
 docs/Makefile.in         |  6 +++---
 docs/makedocs.py         | 11 ++++++++++-
 docs/zzipdoc/document.py |  9 +++++++++
 4 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/docs/Makefile.am b/docs/Makefile.am
index 6f40bb2..d0ceb4a 100644
--- a/docs/Makefile.am
+++ b/docs/Makefile.am
@@ -65,24 +65,24 @@ zziplib.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/lib.h" "--output=zziplib"
-	test -s zziplib.docbook && mv zziplib.docbook zziplib.xml
 zzipmmapped.html: zzipmmapped.xml 
 zzipmmapped.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/zzipdoc/*.py \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/mmapped.h" "--output=zzipmmapped"
-	test -s zzipmmapped.docbook && mv zzipmmapped.docbook zzipmmapped.xml
 zzipfseeko.html: zzipfseeko.xml 
 zzipfseeko.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/zzipdoc/*.py \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/fseeko.h" "--output=zzipfseeko"
-	test -s zzipfseeko.docbook && mv zzipfseeko.docbook zzipfseeko.xml
 
 omfdir=${datadir}/omf
 pkgomfdir=${omfdir}/${PACKAGE}
diff --git a/docs/Makefile.in b/docs/Makefile.in
index acbfefe..f6b3a00 100644
--- a/docs/Makefile.in
+++ b/docs/Makefile.in
@@ -584,24 +584,24 @@ zziplib.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/lib.h" "--output=zziplib"
-	test -s zziplib.docbook && mv zziplib.docbook zziplib.xml
 zzipmmapped.html: zzipmmapped.xml 
 zzipmmapped.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/zzipdoc/*.py \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/mmapped.h" "--output=zzipmmapped"
-	test -s zzipmmapped.docbook && mv zzipmmapped.docbook zzipmmapped.xml
 zzipfseeko.html: zzipfseeko.xml 
 zzipfseeko.xml: zziplib.spec $(srcdir)/Makefile.am \
                  $(srcdir)/zzipdoc/*.py \
                  $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c
 	$(PYRUN) $(srcdir)/makedocs.py @top_srcdir@/zzip/*.c $(zziplib) \
                    "--package=$(PACKAGE)" "--version=$(VERSION)" \
+                   --docbook=xml \
                    "--onlymainheader=zzip/fseeko.h" "--output=zzipfseeko"
-	test -s zzipfseeko.docbook && mv zzipfseeko.docbook zzipfseeko.xml
 
 install-docs: $(doc_FILES) $(man_FILES) site.html htmpages.tar
 	$(mkinstalldirs) $(DESTDIR)$(pkgdocdir)
diff --git a/docs/makedocs.py b/docs/makedocs.py
index 7b30745..99e5e0a 100644
--- a/docs/makedocs.py
+++ b/docs/makedocs.py
@@ -5,6 +5,12 @@
 from collections import OrderedDict
 from optparse import OptionParser
 
+try:
+    # noinspection PyCompatibility
+    from cStringIO import StringIO
+except ImportError:
+    from io import StringIO
+
 from zzipdoc.commentmarkup import CommentMarkup
 from zzipdoc.dbk2htm import section2html, paramdef2html
 from zzipdoc.docbookdocument import DocbookDocument
@@ -261,9 +267,12 @@ def makedocs(filenames, o):  # type: (List[str], Any) -> None
 
 def _save_doc(doc, filename):
     try:
+        print("Preparing {filename}".format(filename=filename))
+        output = StringIO()
+        doc.save(output)
         print("Writing {filename}".format(filename=filename))
         with open(filename, "w") as f:
-            doc.save(f)
+            f.write(output.getvalue())
     except IOError:
         print("Error saving document to {filename}".format(filename=filename))
 
diff --git a/docs/zzipdoc/document.py b/docs/zzipdoc/document.py
index 8fb4176..28fa889 100644
--- a/docs/zzipdoc/document.py
+++ b/docs/zzipdoc/document.py
@@ -1,3 +1,8 @@
+MYPY = False
+if MYPY:
+    from typing import IO
+
+
 class BaseDocument(object):
     def __init__(self):
         self.text = []
@@ -10,3 +15,7 @@ def add(self, text):
     def set_title(self, title):
         self.title = title
         return self
+
+    def save(self, fd):
+        # type: (IO[str]) -> None
+        raise NotImplementedError()
